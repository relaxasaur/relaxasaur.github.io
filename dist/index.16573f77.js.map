{"mappings":"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","sources":["node_modules/@parcel/runtime-browser-hmr/lib/runtime-5cd432c3c54a0b6c.js","Message.js","node_modules/@preact/signals/dist/signals.module.js","node_modules/@preact/signals/src/index.ts","node_modules/@preact/signals-core/dist/signals-core.module.js","node_modules/@preact/signals-core/src/index.ts"],"sourcesContent":["var HMR_HOST = null;var HMR_PORT = null;var HMR_SECURE = false;var HMR_ENV_HASH = \"d6ea1d42532a7575\";var HMR_USE_SSE = false;module.bundle.HMR_BUNDLE_ID = \"be6032d416573f77\";\"use strict\";\n\n/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */\n/*::\nimport type {\n  HMRAsset,\n  HMRMessage,\n} from '@parcel/reporter-dev-server/src/HMRServer.js';\ninterface ParcelRequire {\n  (string): mixed;\n  cache: {|[string]: ParcelModule|};\n  hotData: {|[string]: mixed|};\n  Module: any;\n  parent: ?ParcelRequire;\n  isParcelRequire: true;\n  modules: {|[string]: [Function, {|[string]: string|}]|};\n  HMR_BUNDLE_ID: string;\n  root: ParcelRequire;\n}\ninterface ParcelModule {\n  hot: {|\n    data: mixed,\n    accept(cb: (Function) => void): void,\n    dispose(cb: (mixed) => void): void,\n    // accept(deps: Array<string> | string, cb: (Function) => void): void,\n    // decline(): void,\n    _acceptCallbacks: Array<(Function) => void>,\n    _disposeCallbacks: Array<(mixed) => void>,\n  |};\n}\ninterface ExtensionContext {\n  runtime: {|\n    reload(): void,\n    getURL(url: string): string;\n    getManifest(): {manifest_version: number, ...};\n  |};\n}\ndeclare var module: {bundle: ParcelRequire, ...};\ndeclare var HMR_HOST: string;\ndeclare var HMR_PORT: string;\ndeclare var HMR_ENV_HASH: string;\ndeclare var HMR_SECURE: boolean;\ndeclare var HMR_USE_SSE: boolean;\ndeclare var chrome: ExtensionContext;\ndeclare var browser: ExtensionContext;\ndeclare var __parcel__import__: (string) => Promise<void>;\ndeclare var __parcel__importScripts__: (string) => Promise<void>;\ndeclare var globalThis: typeof self;\ndeclare var ServiceWorkerGlobalScope: Object;\n*/\nvar OVERLAY_ID = '__parcel__error__overlay__';\nvar OldModule = module.bundle.Module;\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData[moduleName],\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n  module.bundle.hotData[moduleName] = undefined;\n}\nmodule.bundle.Module = Module;\nmodule.bundle.hotData = {};\nvar checkedAssets /*: {|[string]: boolean|} */, disposedAssets /*: {|[string]: boolean|} */, assetsToDispose /*: Array<[ParcelRequire, string]> */, assetsToAccept /*: Array<[ParcelRequire, string]> */;\nfunction getHostname() {\n  return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');\n}\nfunction getPort() {\n  return HMR_PORT || location.port;\n}\n\n// eslint-disable-next-line no-redeclare\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = getHostname();\n  var port = getPort();\n  var protocol = HMR_SECURE || location.protocol == 'https:' && !['localhost', '127.0.0.1', '0.0.0.0'].includes(hostname) ? 'wss' : 'ws';\n  var ws;\n  if (HMR_USE_SSE) {\n    ws = new EventSource('/__parcel_hmr');\n  } else {\n    try {\n      ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');\n    } catch (err) {\n      if (err.message) {\n        console.error(err.message);\n      }\n      ws = {};\n    }\n  }\n\n  // Web extension context\n  var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;\n\n  // Safari doesn't support sourceURL in error stacks.\n  // eval may also be disabled via CSP, so do a quick check.\n  var supportsSourceURL = false;\n  try {\n    (0, eval)('throw new Error(\"test\"); //# sourceURL=test.js');\n  } catch (err) {\n    supportsSourceURL = err.stack.includes('test.js');\n  }\n\n  // $FlowFixMe\n  ws.onmessage = async function (event /*: {data: string, ...} */) {\n    checkedAssets = {} /*: {|[string]: boolean|} */;\n    disposedAssets = {} /*: {|[string]: boolean|} */;\n    assetsToAccept = [];\n    assetsToDispose = [];\n    var data /*: HMRMessage */ = JSON.parse(event.data);\n    if (data.type === 'reload') {\n      fullReload();\n    } else if (data.type === 'update') {\n      // Remove error overlay if there is one\n      if (typeof document !== 'undefined') {\n        removeErrorOverlay();\n      }\n      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH);\n\n      // Handle HMR Update\n      let handled = assets.every(asset => {\n        return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);\n      });\n      if (handled) {\n        console.clear();\n\n        // Dispatch custom event so other runtimes (e.g React Refresh) are aware.\n        if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') {\n          window.dispatchEvent(new CustomEvent('parcelhmraccept'));\n        }\n        await hmrApplyUpdates(assets);\n        hmrDisposeQueue();\n\n        // Run accept callbacks. This will also re-execute other disposed assets in topological order.\n        let processedAssets = {};\n        for (let i = 0; i < assetsToAccept.length; i++) {\n          let id = assetsToAccept[i][1];\n          if (!processedAssets[id]) {\n            hmrAccept(assetsToAccept[i][0], id);\n            processedAssets[id] = true;\n          }\n        }\n      } else fullReload();\n    }\n    if (data.type === 'error') {\n      // Log parcel errors to console\n      for (let ansiDiagnostic of data.diagnostics.ansi) {\n        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;\n        console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\\n' + stack + '\\n\\n' + ansiDiagnostic.hints.join('\\n'));\n      }\n      if (typeof document !== 'undefined') {\n        // Render the fancy html overlay\n        removeErrorOverlay();\n        var overlay = createErrorOverlay(data.diagnostics.html);\n        // $FlowFixMe\n        document.body.appendChild(overlay);\n      }\n    }\n  };\n  if (ws instanceof WebSocket) {\n    ws.onerror = function (e) {\n      if (e.message) {\n        console.error(e.message);\n      }\n    };\n    ws.onclose = function () {\n      console.warn('[parcel] 🚨 Connection to the HMR server was lost');\n    };\n  }\n}\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n    console.log('[parcel] ✨ Error resolved');\n  }\n}\nfunction createErrorOverlay(diagnostics) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n  let errorHTML = '<div style=\"background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;\">';\n  for (let diagnostic of diagnostics) {\n    let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame) => {\n      return `${p}\n<a href=\"/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}\" style=\"text-decoration: underline; color: #888\" onclick=\"fetch(this.href); return false\">${frame.location}</a>\n${frame.code}`;\n    }, '') : diagnostic.stack;\n    errorHTML += `\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          🚨 ${diagnostic.message}\n        </div>\n        <pre>${stack}</pre>\n        <div>\n          ${diagnostic.hints.map(hint => '<div>💡 ' + hint + '</div>').join('')}\n        </div>\n        ${diagnostic.documentation ? `<div>📝 <a style=\"color: violet\" href=\"${diagnostic.documentation}\" target=\"_blank\">Learn more</a></div>` : ''}\n      </div>\n    `;\n  }\n  errorHTML += '</div>';\n  overlay.innerHTML = errorHTML;\n  return overlay;\n}\nfunction fullReload() {\n  if ('reload' in location) {\n    location.reload();\n  } else if (extCtx && extCtx.runtime && extCtx.runtime.reload) {\n    extCtx.runtime.reload();\n  }\n}\nfunction getParents(bundle, id) /*: Array<[ParcelRequire, string]> */{\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n  var parents = [];\n  var k, d, dep;\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {\n        parents.push([bundle, k]);\n      }\n    }\n  }\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n  return parents;\n}\nfunction updateLink(link) {\n  var href = link.getAttribute('href');\n  if (!href) {\n    return;\n  }\n  var newLink = link.cloneNode();\n  newLink.onload = function () {\n    if (link.parentNode !== null) {\n      // $FlowFixMe\n      link.parentNode.removeChild(link);\n    }\n  };\n  newLink.setAttribute('href',\n  // $FlowFixMe\n  href.split('?')[0] + '?' + Date.now());\n  // $FlowFixMe\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\nvar cssTimeout = null;\nfunction reloadCSS() {\n  if (cssTimeout) {\n    return;\n  }\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n    for (var i = 0; i < links.length; i++) {\n      // $FlowFixMe[incompatible-type]\n      var href /*: string */ = links[i].getAttribute('href');\n      var hostname = getHostname();\n      var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\\\/\\\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());\n      var absolute = /^https?:\\/\\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;\n      if (!absolute) {\n        updateLink(links[i]);\n      }\n    }\n    cssTimeout = null;\n  }, 50);\n}\nfunction hmrDownload(asset) {\n  if (asset.type === 'js') {\n    if (typeof document !== 'undefined') {\n      let script = document.createElement('script');\n      script.src = asset.url + '?t=' + Date.now();\n      if (asset.outputFormat === 'esmodule') {\n        script.type = 'module';\n      }\n      return new Promise((resolve, reject) => {\n        var _document$head;\n        script.onload = () => resolve(script);\n        script.onerror = reject;\n        (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);\n      });\n    } else if (typeof importScripts === 'function') {\n      // Worker scripts\n      if (asset.outputFormat === 'esmodule') {\n        return __parcel__import__(asset.url + '?t=' + Date.now());\n      } else {\n        return new Promise((resolve, reject) => {\n          try {\n            __parcel__importScripts__(asset.url + '?t=' + Date.now());\n            resolve();\n          } catch (err) {\n            reject(err);\n          }\n        });\n      }\n    }\n  }\n}\nasync function hmrApplyUpdates(assets) {\n  global.parcelHotUpdate = Object.create(null);\n  let scriptsToRemove;\n  try {\n    // If sourceURL comments aren't supported in eval, we need to load\n    // the update from the dev server over HTTP so that stack traces\n    // are correct in errors/logs. This is much slower than eval, so\n    // we only do it if needed (currently just Safari).\n    // https://bugs.webkit.org/show_bug.cgi?id=137297\n    // This path is also taken if a CSP disallows eval.\n    if (!supportsSourceURL) {\n      let promises = assets.map(asset => {\n        var _hmrDownload;\n        return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch(err => {\n          // Web extension fix\n          if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {\n            extCtx.runtime.reload();\n            return;\n          }\n          throw err;\n        });\n      });\n      scriptsToRemove = await Promise.all(promises);\n    }\n    assets.forEach(function (asset) {\n      hmrApply(module.bundle.root, asset);\n    });\n  } finally {\n    delete global.parcelHotUpdate;\n    if (scriptsToRemove) {\n      scriptsToRemove.forEach(script => {\n        if (script) {\n          var _document$head2;\n          (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);\n        }\n      });\n    }\n  }\n}\nfunction hmrApply(bundle /*: ParcelRequire */, asset /*:  HMRAsset */) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (asset.type === 'css') {\n    reloadCSS();\n  } else if (asset.type === 'js') {\n    let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];\n    if (deps) {\n      if (modules[asset.id]) {\n        // Remove dependencies that are removed and will become orphaned.\n        // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.\n        let oldDeps = modules[asset.id][1];\n        for (let dep in oldDeps) {\n          if (!deps[dep] || deps[dep] !== oldDeps[dep]) {\n            let id = oldDeps[dep];\n            let parents = getParents(module.bundle.root, id);\n            if (parents.length === 1) {\n              hmrDelete(module.bundle.root, id);\n            }\n          }\n        }\n      }\n      if (supportsSourceURL) {\n        // Global eval. We would use `new Function` here but browser\n        // support for source maps is better with eval.\n        (0, eval)(asset.output);\n      }\n\n      // $FlowFixMe\n      let fn = global.parcelHotUpdate[asset.id];\n      modules[asset.id] = [fn, deps];\n    }\n\n    // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.\n    // This is required in case modules are duplicated. We need to ensure all instances have the updated code.\n    if (bundle.parent) {\n      hmrApply(bundle.parent, asset);\n    }\n  }\n}\nfunction hmrDelete(bundle, id) {\n  let modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (modules[id]) {\n    // Collect dependencies that will become orphaned when this module is deleted.\n    let deps = modules[id][1];\n    let orphans = [];\n    for (let dep in deps) {\n      let parents = getParents(module.bundle.root, deps[dep]);\n      if (parents.length === 1) {\n        orphans.push(deps[dep]);\n      }\n    }\n\n    // Delete the module. This must be done before deleting dependencies in case of circular dependencies.\n    delete modules[id];\n    delete bundle.cache[id];\n\n    // Now delete the orphans.\n    orphans.forEach(id => {\n      hmrDelete(module.bundle.root, id);\n    });\n  } else if (bundle.parent) {\n    hmrDelete(bundle.parent, id);\n  }\n}\nfunction hmrAcceptCheck(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  if (hmrAcceptCheckOne(bundle, id, depsByBundle)) {\n    return true;\n  }\n\n  // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.\n  let parents = getParents(module.bundle.root, id);\n  let accepted = false;\n  while (parents.length > 0) {\n    let v = parents.shift();\n    let a = hmrAcceptCheckOne(v[0], v[1], null);\n    if (a) {\n      // If this parent accepts, stop traversing upward, but still consider siblings.\n      accepted = true;\n    } else {\n      // Otherwise, queue the parents in the next level upward.\n      let p = getParents(module.bundle.root, v[1]);\n      if (p.length === 0) {\n        // If there are no parents, then we've reached an entry without accepting. Reload.\n        accepted = false;\n        break;\n      }\n      parents.push(...p);\n    }\n  }\n  return accepted;\n}\nfunction hmrAcceptCheckOne(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {\n    // If we reached the root bundle without finding where the asset should go,\n    // there's nothing to do. Mark as \"accepted\" so we don't reload the page.\n    if (!bundle.parent) {\n      return true;\n    }\n    return hmrAcceptCheck(bundle.parent, id, depsByBundle);\n  }\n  if (checkedAssets[id]) {\n    return true;\n  }\n  checkedAssets[id] = true;\n  var cached = bundle.cache[id];\n  assetsToDispose.push([bundle, id]);\n  if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {\n    assetsToAccept.push([bundle, id]);\n    return true;\n  }\n}\nfunction hmrDisposeQueue() {\n  // Dispose all old assets.\n  for (let i = 0; i < assetsToDispose.length; i++) {\n    let id = assetsToDispose[i][1];\n    if (!disposedAssets[id]) {\n      hmrDispose(assetsToDispose[i][0], id);\n      disposedAssets[id] = true;\n    }\n  }\n  assetsToDispose = [];\n}\nfunction hmrDispose(bundle /*: ParcelRequire */, id /*: string */) {\n  var cached = bundle.cache[id];\n  bundle.hotData[id] = {};\n  if (cached && cached.hot) {\n    cached.hot.data = bundle.hotData[id];\n  }\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData[id]);\n    });\n  }\n  delete bundle.cache[id];\n}\nfunction hmrAccept(bundle /*: ParcelRequire */, id /*: string */) {\n  // Execute the module.\n  bundle(id);\n\n  // Run the accept callbacks in the new version of the module.\n  var cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    let assetsToAlsoAccept = [];\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      let additionalAssets = cb(function () {\n        return getParents(module.bundle.root, id);\n      });\n      if (Array.isArray(additionalAssets) && additionalAssets.length) {\n        assetsToAlsoAccept.push(...additionalAssets);\n      }\n    });\n    if (assetsToAlsoAccept.length) {\n      let handled = assetsToAlsoAccept.every(function (a) {\n        return hmrAcceptCheck(a[0], a[1]);\n      });\n      if (!handled) {\n        return fullReload();\n      }\n      hmrDisposeQueue();\n    }\n  }\n}","import React from 'preact';\r\nimport { render } from 'preact';\r\nimport { useState } from 'preact/hooks';\r\nimport { signal } from '@preact/signals';\r\n\r\nfunction Message() {\r\n    const [cravePoints, setPoints] = useState(0);\r\n\r\n    function increment() {\r\n        setPoints(cravePoints+1)\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            <h5>{cravePoints} crave points</h5>\r\n            <button id=\"pressable\" onClick={increment}></button>\r\n        </div>     \r\n    );\r\n}\r\n\r\nconst target = document.getElementById('message');\r\nrender(<Message />, target);\r\n\r\n",null,"import { options, Component, isValidElement } from \"preact\";\nimport { useRef, useMemo, useEffect } from \"preact/hooks\";\nimport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n\tuntracked,\n} from \"@preact/signals-core\";\nimport {\n\tVNode,\n\tOptionsTypes,\n\tHookFn,\n\tEffect,\n\tPropertyUpdater,\n\tAugmentedComponent,\n\tAugmentedElement as Element,\n} from \"./internal\";\n\nexport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n\tuntracked,\n};\n\nconst HAS_PENDING_UPDATE = 1 << 0;\nconst HAS_HOOK_STATE = 1 << 1;\nconst HAS_COMPUTEDS = 1 << 2;\n\nlet oldNotify: (this: Effect) => void,\n\teffectsQueue: Array<Effect> = [],\n\tdomQueue: Array<Effect> = [];\n\n// Capture the original `Effect.prototype._notify` method so that we can install\n// custom `._notify`s for each different use-case but still call the original\n// implementation in the end. Dispose the temporary effect immediately afterwards.\neffect(function (this: Effect) {\n\toldNotify = this._notify;\n})();\n\n// Install a Preact options hook\nfunction hook<T extends OptionsTypes>(hookName: T, hookFn: HookFn<T>) {\n\t// @ts-ignore-next-line private options hooks usage\n\toptions[hookName] = hookFn.bind(null, options[hookName] || (() => {}));\n}\n\nlet currentComponent: AugmentedComponent | undefined;\nlet finishUpdate: (() => void) | undefined;\n\nfunction setCurrentUpdater(updater?: Effect) {\n\t// end tracking for the current update:\n\tif (finishUpdate) finishUpdate();\n\t// start tracking the new update:\n\tfinishUpdate = updater && updater._start();\n}\n\nfunction createUpdater(update: () => void) {\n\tlet updater!: Effect;\n\teffect(function (this: Effect) {\n\t\tupdater = this;\n\t});\n\tupdater._callback = update;\n\treturn updater;\n}\n\n/** @todo This may be needed for complex prop value detection. */\n// function isSignalValue(value: any): value is Signal {\n// \tif (typeof value !== \"object\" || value == null) return false;\n// \tif (value instanceof Signal) return true;\n// \t// @TODO: uncomment this when we land Reactive (ideally behind a brand check)\n// \t// for (let i in value) if (value[i] instanceof Signal) return true;\n// \treturn false;\n// }\n\n/**\n * A wrapper component that renders a Signal directly as a Text node.\n * @todo: in Preact 11, just decorate Signal with `type:null`\n */\nfunction SignalValue(this: AugmentedComponent, { data }: { data: Signal }) {\n\t// hasComputeds.add(this);\n\n\t// Store the props.data signal in another signal so that\n\t// passing a new signal reference re-runs the text computed:\n\tconst currentSignal = useSignal(data);\n\tcurrentSignal.value = data;\n\n\tconst [isText, s] = useMemo(() => {\n\t\tlet self = this;\n\t\t// mark the parent component as having computeds so it gets optimized\n\t\tlet v = this.__v;\n\t\twhile ((v = v.__!)) {\n\t\t\tif (v.__c) {\n\t\t\t\tv.__c._updateFlags |= HAS_COMPUTEDS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst wrappedSignal = computed(() => {\n\t\t\tlet s = currentSignal.value.value;\n\t\t\treturn s === 0 ? 0 : s === true ? \"\" : s || \"\";\n\t\t});\n\n\t\tconst isText = computed(() => !isValidElement(wrappedSignal.value));\n\n\t\t// Update text nodes directly without rerendering when the new value\n\t\t// is also text.\n\t\tconst dispose = effect(function (this: Effect) {\n\t\t\tthis._notify = notifyDomUpdates;\n\n\t\t\t// Subscribe to wrappedSignal updates only when its values are text...\n\t\t\tif (isText.value) {\n\t\t\t\t// ...but regardless of `self.base`'s current value, as it can be\n\t\t\t\t// undefined before mounting or a non-text node. In both of those cases\n\t\t\t\t// the update gets handled by a full rerender.\n\t\t\t\tconst value = wrappedSignal.value;\n\t\t\t\tif (self.base && self.base.nodeType === 3) {\n\t\t\t\t\t(self.base as Text).data = value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Piggyback this._updater's disposal to ensure that the text updater effect\n\t\t// above also gets disposed on unmount.\n\t\tconst oldDispose = this._updater!._dispose;\n\t\tthis._updater!._dispose = function () {\n\t\t\tdispose();\n\t\t\toldDispose.call(this);\n\t\t};\n\n\t\treturn [isText, wrappedSignal];\n\t}, []);\n\n\t// Rerender the component whenever `data.value` changes from a VNode\n\t// to another VNode, from text to a VNode, or from a VNode to text.\n\t// That is, everything else except text-to-text updates.\n\t//\n\t// This also ensures that the backing DOM node types gets updated to\n\t// text nodes and back when needed.\n\t//\n\t// For text-to-text updates, `.peek()` is used to skip full rerenders,\n\t// leaving them to the optimized path above.\n\treturn isText.value ? s.peek() : s.value;\n}\nSignalValue.displayName = \"_st\";\n\nObject.defineProperties(Signal.prototype, {\n\tconstructor: { configurable: true, value: undefined },\n\ttype: { configurable: true, value: SignalValue },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\t// Setting a VNode's _depth to 1 forces Preact to clone it before modifying:\n\t// https://github.com/preactjs/preact/blob/d7a433ee8463a7dc23a05111bb47de9ec729ad4d/src/diff/children.js#L77\n\t// @todo remove this for Preact 11\n\t__b: { configurable: true, value: 1 },\n});\n\n/** Inject low-level property/attribute bindings for Signals into Preact's diff */\nhook(OptionsTypes.DIFF, (old, vnode) => {\n\tif (typeof vnode.type === \"string\") {\n\t\tlet signalProps: Record<string, any> | undefined;\n\n\t\tlet props = vnode.props;\n\t\tfor (let i in props) {\n\t\t\tif (i === \"children\") continue;\n\n\t\t\tlet value = props[i];\n\t\t\tif (value instanceof Signal) {\n\t\t\t\tif (!signalProps) vnode.__np = signalProps = {};\n\t\t\t\tsignalProps[i] = value;\n\t\t\t\tprops[i] = value.peek();\n\t\t\t}\n\t\t}\n\t}\n\n\told(vnode);\n});\n\n/** Set up Updater before rendering a component */\nhook(OptionsTypes.RENDER, (old, vnode) => {\n\tsetCurrentUpdater();\n\n\tlet updater;\n\n\tlet component = vnode.__c;\n\tif (component) {\n\t\tcomponent._updateFlags &= ~HAS_PENDING_UPDATE;\n\n\t\tupdater = component._updater;\n\t\tif (updater === undefined) {\n\t\t\tcomponent._updater = updater = createUpdater(() => {\n\t\t\t\tcomponent._updateFlags |= HAS_PENDING_UPDATE;\n\t\t\t\tcomponent.setState({});\n\t\t\t});\n\t\t}\n\t}\n\n\tcurrentComponent = component;\n\tsetCurrentUpdater(updater);\n\told(vnode);\n});\n\n/** Finish current updater if a component errors */\nhook(OptionsTypes.CATCH_ERROR, (old, error, vnode, oldVNode) => {\n\tsetCurrentUpdater();\n\tcurrentComponent = undefined;\n\told(error, vnode, oldVNode);\n});\n\n/** Finish current updater after rendering any VNode */\nhook(OptionsTypes.DIFFED, (old, vnode) => {\n\tsetCurrentUpdater();\n\tcurrentComponent = undefined;\n\n\tlet dom: Element;\n\n\t// vnode._dom is undefined during string rendering,\n\t// so we use this to skip prop subscriptions during SSR.\n\tif (typeof vnode.type === \"string\" && (dom = vnode.__e as Element)) {\n\t\tlet props = vnode.__np;\n\t\tlet renderedProps = vnode.props;\n\t\tif (props) {\n\t\t\tlet updaters = dom._updaters;\n\t\t\tif (updaters) {\n\t\t\t\tfor (let prop in updaters) {\n\t\t\t\t\tlet updater = updaters[prop];\n\t\t\t\t\tif (updater !== undefined && !(prop in props)) {\n\t\t\t\t\t\tupdater._dispose();\n\t\t\t\t\t\t// @todo we could just always invoke _dispose() here\n\t\t\t\t\t\tupdaters[prop] = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tupdaters = {};\n\t\t\t\tdom._updaters = updaters;\n\t\t\t}\n\t\t\tfor (let prop in props) {\n\t\t\t\tlet updater = updaters[prop];\n\t\t\t\tlet signal = props[prop];\n\t\t\t\tif (updater === undefined) {\n\t\t\t\t\tupdater = createPropUpdater(dom, prop, signal, renderedProps);\n\t\t\t\t\tupdaters[prop] = updater;\n\t\t\t\t} else {\n\t\t\t\t\tupdater._update(signal, renderedProps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\told(vnode);\n});\n\nfunction createPropUpdater(\n\tdom: Element,\n\tprop: string,\n\tpropSignal: Signal,\n\tprops: Record<string, any>\n): PropertyUpdater {\n\tconst setAsProperty =\n\t\tprop in dom &&\n\t\t// SVG elements need to go through `setAttribute` because they\n\t\t// expect things like SVGAnimatedTransformList instead of strings.\n\t\t// @ts-ignore\n\t\tdom.ownerSVGElement === undefined;\n\n\tconst changeSignal = signal(propSignal);\n\treturn {\n\t\t_update: (newSignal: Signal, newProps: typeof props) => {\n\t\t\tchangeSignal.value = newSignal;\n\t\t\tprops = newProps;\n\t\t},\n\t\t_dispose: effect(function (this: Effect) {\n\t\t\tthis._notify = notifyDomUpdates;\n\t\t\tconst value = changeSignal.value.value;\n\t\t\t// If Preact just rendered this value, don't render it again:\n\t\t\tif (props[prop] === value) return;\n\t\t\tprops[prop] = value;\n\t\t\tif (setAsProperty) {\n\t\t\t\t// @ts-ignore-next-line silly\n\t\t\t\tdom[prop] = value;\n\t\t\t} else if (value) {\n\t\t\t\tdom.setAttribute(prop, value);\n\t\t\t} else {\n\t\t\t\tdom.removeAttribute(prop);\n\t\t\t}\n\t\t}),\n\t};\n}\n\n/** Unsubscribe from Signals when unmounting components/vnodes */\nhook(OptionsTypes.UNMOUNT, (old, vnode: VNode) => {\n\tif (typeof vnode.type === \"string\") {\n\t\tlet dom = vnode.__e as Element | undefined;\n\t\t// vnode._dom is undefined during string rendering\n\t\tif (dom) {\n\t\t\tconst updaters = dom._updaters;\n\t\t\tif (updaters) {\n\t\t\t\tdom._updaters = undefined;\n\t\t\t\tfor (let prop in updaters) {\n\t\t\t\t\tlet updater = updaters[prop];\n\t\t\t\t\tif (updater) updater._dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlet component = vnode.__c;\n\t\tif (component) {\n\t\t\tconst updater = component._updater;\n\t\t\tif (updater) {\n\t\t\t\tcomponent._updater = undefined;\n\t\t\t\tupdater._dispose();\n\t\t\t}\n\t\t}\n\t}\n\told(vnode);\n});\n\n/** Mark components that use hook state so we can skip sCU optimization. */\nhook(OptionsTypes.HOOK, (old, component, index, type) => {\n\tif (type < 3 || type === 9)\n\t\t(component as AugmentedComponent)._updateFlags |= HAS_HOOK_STATE;\n\told(component, index, type);\n});\n\n/**\n * Auto-memoize components that use Signals/Computeds.\n * Note: Does _not_ optimize components that use hook/class state.\n */\nComponent.prototype.shouldComponentUpdate = function (\n\tthis: AugmentedComponent,\n\tprops,\n\tstate\n) {\n\t// @todo: Once preactjs/preact#3671 lands, this could just use `currentUpdater`:\n\tconst updater = this._updater;\n\tconst hasSignals = updater && updater._sources !== undefined;\n\n\t// If this is a component using state, rerender\n\t// @ts-ignore\n\tfor (let i in state) return true;\n\n\tif (this.__f || (typeof this.u == \"boolean\" && this.u === true)) {\n\t\tconst hasHooksState = this._updateFlags & HAS_HOOK_STATE;\n\t\t// if this component used no signals or computeds and no hooks state, update:\n\t\tif (!hasSignals && !hasHooksState && !(this._updateFlags & HAS_COMPUTEDS))\n\t\t\treturn true;\n\n\t\t// if there is a pending re-render triggered from Signals,\n\t\t// or if there is hooks state, update:\n\t\tif (this._updateFlags & HAS_PENDING_UPDATE) return true;\n\t} else {\n\t\t// if this component used no signals or computeds, update:\n\t\tif (!hasSignals && !(this._updateFlags & HAS_COMPUTEDS)) return true;\n\n\t\t// if there is a pending re-render triggered from Signals,\n\t\t// or if there is hooks state, update:\n\t\tif (this._updateFlags & (HAS_PENDING_UPDATE | HAS_HOOK_STATE)) return true;\n\t}\n\n\t// if any non-Signal props changed, update:\n\tfor (let i in props) {\n\t\tif (i !== \"__source\" && props[i] !== this.props[i]) return true;\n\t}\n\tfor (let i in this.props) if (!(i in props)) return true;\n\n\t// this is a purely Signal-driven component, don't update:\n\treturn false;\n};\n\nexport function useSignal<T>(value: T): Signal<T>;\nexport function useSignal<T = undefined>(): Signal<T | undefined>;\nexport function useSignal<T>(value?: T) {\n\treturn useMemo(() => signal<T | undefined>(value), []);\n}\n\nexport function useComputed<T>(compute: () => T) {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\t(currentComponent as AugmentedComponent)._updateFlags |= HAS_COMPUTEDS;\n\treturn useMemo(() => computed<T>(() => $compute.current()), []);\n}\n\nconst deferEffects =\n\ttypeof requestAnimationFrame === \"undefined\"\n\t\t? setTimeout\n\t\t: requestAnimationFrame;\n\nconst deferDomUpdates = (cb: any) => {\n\tqueueMicrotask(() => {\n\t\tqueueMicrotask(cb);\n\t});\n};\n\nfunction flushEffects() {\n\tbatch(() => {\n\t\tlet inst: Effect | undefined;\n\t\twhile ((inst = effectsQueue.shift())) {\n\t\t\toldNotify.call(inst);\n\t\t}\n\t});\n}\n\nfunction notifyEffects(this: Effect) {\n\tif (effectsQueue.push(this) === 1) {\n\t\t(options.requestAnimationFrame || deferEffects)(flushEffects);\n\t}\n}\n\nfunction flushDomUpdates() {\n\tbatch(() => {\n\t\tlet inst: Effect | undefined;\n\t\twhile ((inst = domQueue.shift())) {\n\t\t\toldNotify.call(inst);\n\t\t}\n\t});\n}\n\nfunction notifyDomUpdates(this: Effect) {\n\tif (domQueue.push(this) === 1) {\n\t\t(options.requestAnimationFrame || deferDomUpdates)(flushDomUpdates);\n\t}\n}\n\nexport function useSignalEffect(cb: () => void | (() => void)) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(function (this: Effect) {\n\t\t\tthis._notify = notifyEffects;\n\t\t\treturn callback.current();\n\t\t});\n\t}, []);\n}\n\n/**\n * @todo Determine which Reactive implementation we'll be using.\n * @internal\n */\n// export function useReactive<T extends object>(value: T): Reactive<T> {\n// \treturn useMemo(() => reactive<T>(value), []);\n// }\n\n/**\n * @internal\n * Update a Reactive's using the properties of an object or other Reactive.\n * Also works for Signals.\n * @example\n *   // Update a Reactive with Object.assign()-like syntax:\n *   const r = reactive({ name: \"Alice\" });\n *   update(r, { name: \"Bob\" });\n *   update(r, { age: 42 }); // property 'age' does not exist in type '{ name?: string }'\n *   update(r, 2); // '2' has no properties in common with '{ name?: string }'\n *   console.log(r.name.value); // \"Bob\"\n *\n * @example\n *   // Update a Reactive with the properties of another Reactive:\n *   const A = reactive({ name: \"Alice\" });\n *   const B = reactive({ name: \"Bob\", age: 42 });\n *   update(A, B);\n *   console.log(`${A.name} is ${A.age}`); // \"Bob is 42\"\n *\n * @example\n *   // Update a signal with assign()-like syntax:\n *   const s = signal(42);\n *   update(s, \"hi\"); // Argument type 'string' not assignable to type 'number'\n *   update(s, {}); // Argument type '{}' not assignable to type 'number'\n *   update(s, 43);\n *   console.log(s.value); // 43\n *\n * @param obj The Reactive or Signal to be updated\n * @param update The value, Signal, object or Reactive to update `obj` to match\n * @param overwrite If `true`, any properties `obj` missing from `update` are set to `undefined`\n */\n/*\nexport function update<T extends SignalOrReactive>(\n\tobj: T,\n\tupdate: Partial<Unwrap<T>>,\n\toverwrite = false\n) {\n\tif (obj instanceof Signal) {\n\t\tobj.value = peekValue(update);\n\t} else {\n\t\tfor (let i in update) {\n\t\t\tif (i in obj) {\n\t\t\t\tobj[i].value = peekValue(update[i]);\n\t\t\t} else {\n\t\t\t\tlet sig = signal(peekValue(update[i]));\n\t\t\t\tsig[KEY] = i;\n\t\t\t\tobj[i] = sig;\n\t\t\t}\n\t\t}\n\t\tif (overwrite) {\n\t\t\tfor (let i in obj) {\n\t\t\t\tif (!(i in update)) {\n\t\t\t\t\tobj[i].value = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n*/\n",null,"// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn fn();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *         ↑     ↑\n\t\t *        tail  node (new)\n\t\t *               ↓\n\t\t * { A <-> B <-> C }\n\t\t *               ↑\n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *         ↑           ↑\n\t\t *        node   ┌─── tail (evalContext._sources)\n\t\t *         └─────│─────┐\n\t\t *               ↓     ↓\n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     ↑\n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style prototypes.\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tbrand: typeof BRAND_SYMBOL;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style prototypes.\n// This enables better control of the transpiled output size.\nfunction Signal(this: Signal, value?: unknown) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tif (this._targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = this._targets;\n\t\tif (this._targets !== undefined) {\n\t\t\tthis._targets._prevTarget = node;\n\t\t}\n\t\tthis._targets = node;\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\treturn effect(() => {\n\t\tconst value = this.value;\n\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tfn(value);\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t}\n\t});\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn this.value;\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget(this: Signal) {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tthrow new Error(\"Cycle detected\");\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T): Signal<T> {\n\treturn new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\t// If there's a new version of the dependency before or after refreshing,\n\t\t// or the dependency has something blocking it from refreshing at all (e.g. a\n\t\t// dependency cycle), then we need to recompute.\n\t\tif (\n\t\t\tnode._source._version !== node._version ||\n\t\t\t!node._source._refresh() ||\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                   ↑           ↑\n\t *                   │           └──────┐\n\t * target._sources = A; (node is head)  │\n\t *                   ↓                  │\n\t * target._sources = C; (node is tail) ─┘\n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         ↓\n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *   ↑     ↑     ↑\n\t\t\t *   │     │     └ head = node\n\t\t\t *   │     └ head = node\n\t\t\t *   └ head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n\t_fn: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(fn: () => T);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\nfunction Computed(this: Computed, fn: () => unknown) {\n\tSignal.call(this, undefined);\n\n\tthis._fn = fn;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._fn();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget(this: Computed) {\n\t\tif (this._flags & RUNNING) {\n\t\t\tthrow new Error(\"Cycle detected\");\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n\treadonly value: T;\n\tpeek(): T;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\tvalueOf(): T;\n\ttoString(): string;\n\ttoJSON(): T;\n\tbrand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n\treturn new Computed(fn);\n}\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._fn = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectFn = () => void | (() => void);\n\ndeclare class Effect {\n\t_fn?: EffectFn;\n\t_cleanup?: () => void;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\n\tconstructor(fn: EffectFn);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n}\n\nfunction Effect(this: Effect, fn: EffectFn) {\n\tthis._fn = fn;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._fn === undefined) return;\n\n\t\tconst cleanup = this._fn();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tthrow new Error(\"Cycle detected\");\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n\tconst effect = new Effect(fn);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\treturn effect._dispose.bind(effect);\n}\n\nexport { computed, effect, batch, untracked, Signal, ReadonlySignal };\n"],"names":["oldNotify","currentComponent","finishUpdate","effectsQueue","domQueue","effect","this","_notify","hook","hookName","hookFn","options","bind","setCurrentUpdater","updater","_start","SignalValue","_ref","_this","data","currentSignal","useSignal","value","_useMemo","useMemo","self","v","__v","__","__c","_updateFlags","wrappedSignal","computed","s","isText","isValidElement","dispose","notifyDomUpdates","base","nodeType","oldDispose","_updater","_dispose","call","peek","displayName","Object","defineProperties","Signal","prototype","constructor","configurable","undefined","type","props","get","__b","old","vnode","signalProps","i","__np","component","update","_callback","setState","createUpdater","error","oldVNode","dom","__e","renderedProps","updaters","_updaters","prop","signal","createPropUpdater","_update","propSignal","setAsProperty","ownerSVGElement","changeSignal","newSignal","newProps","setAttribute","removeAttribute","index","Component","shouldComponentUpdate","state","hasSignals","_sources","__f","u","hasHooksState","useComputed","compute","$compute","useRef","current","deferEffects","requestAnimationFrame","setTimeout","deferDomUpdates","cb","queueMicrotask","flushEffects","batch","inst","shift","notifyEffects","push","flushDomUpdates","useSignalEffect","callback","useEffect","BRAND_SYMBOL","Symbol","endBatch","batchDepth","hasError","batchedEffect","batchIteration","next","_nextBatchedEffect","_flags","needsToRecompute","err","fn","evalContext","untracked","prevContext","globalVersion","addDependency","node","_node","_target","_version","_source","_prevSource","_nextSource","_prevTarget","_nextTarget","_rollbackNode","_subscribe","_value","_targets","brand","_refresh","_unsubscribe","prev","subscribe","valueOf","toString","toJSON","defineProperty","set","Error","target","prepareSources","rollbackNode","cleanupSources","head","Computed","_fn","_globalVersion","OUTDATED","cleanupEffect","cleanup","_cleanup","disposeEffect","endEffect","Effect","finish"],"version":3,"file":"index.16573f77.js.map","sourceRoot":"/__parcel_source_root/"}