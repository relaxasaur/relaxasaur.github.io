{"mappings":"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","sources":["node_modules/@parcel/runtime-browser-hmr/lib/runtime-3b20d14935589f1c.js","CountUp.js","node_modules/preact/compat/jsx-dev-runtime.js","node_modules/preact/compat/dist/compat.module.js","node_modules/preact/compat/src/util.js","node_modules/preact/compat/src/hooks.js","node_modules/preact/compat/src/PureComponent.js","node_modules/preact/compat/src/memo.js","node_modules/preact/compat/src/forwardRef.js","node_modules/preact/compat/src/Children.js","node_modules/preact/compat/src/suspense.js","node_modules/preact/compat/src/suspense-list.js","node_modules/preact/src/constants.js","node_modules/preact/compat/src/portals.js","node_modules/preact/compat/src/render.js","node_modules/preact/compat/src/index.js","node_modules/preact/dist/preact.module.js","node_modules/preact/src/util.js","node_modules/preact/src/options.js","node_modules/preact/src/create-element.js","node_modules/preact/src/component.js","node_modules/preact/src/diff/props.js","node_modules/preact/src/create-context.js","node_modules/preact/src/diff/children.js","node_modules/preact/src/diff/index.js","node_modules/preact/src/render.js","node_modules/preact/src/clone-element.js","node_modules/preact/src/diff/catch-error.js","node_modules/@parcel/transformer-js/src/esmodule-helpers.js","node_modules/preact/hooks/dist/hooks.module.js","node_modules/preact/hooks/src/index.js","node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js","node_modules/preact/jsx-runtime/src/utils.js","node_modules/preact/jsx-runtime/src/index.js","node_modules/react-timer-hook/dist/index.js","node_modules/@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js","node_modules/react-refresh/runtime.js","node_modules/react-refresh/cjs/react-refresh-runtime.development.js","node_modules/react-refresh/package.json"],"sourcesContent":["var HMR_HOST = null;var HMR_PORT = null;var HMR_SECURE = false;var HMR_ENV_HASH = \"d6ea1d42532a7575\";var HMR_USE_SSE = false;module.bundle.HMR_BUNDLE_ID = \"b59a2c58cbef2d5a\";\"use strict\";\n\n/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */\n/*::\nimport type {\n  HMRAsset,\n  HMRMessage,\n} from '@parcel/reporter-dev-server/src/HMRServer.js';\ninterface ParcelRequire {\n  (string): mixed;\n  cache: {|[string]: ParcelModule|};\n  hotData: {|[string]: mixed|};\n  Module: any;\n  parent: ?ParcelRequire;\n  isParcelRequire: true;\n  modules: {|[string]: [Function, {|[string]: string|}]|};\n  HMR_BUNDLE_ID: string;\n  root: ParcelRequire;\n}\ninterface ParcelModule {\n  hot: {|\n    data: mixed,\n    accept(cb: (Function) => void): void,\n    dispose(cb: (mixed) => void): void,\n    // accept(deps: Array<string> | string, cb: (Function) => void): void,\n    // decline(): void,\n    _acceptCallbacks: Array<(Function) => void>,\n    _disposeCallbacks: Array<(mixed) => void>,\n  |};\n}\ninterface ExtensionContext {\n  runtime: {|\n    reload(): void,\n    getURL(url: string): string;\n    getManifest(): {manifest_version: number, ...};\n  |};\n}\ndeclare var module: {bundle: ParcelRequire, ...};\ndeclare var HMR_HOST: string;\ndeclare var HMR_PORT: string;\ndeclare var HMR_ENV_HASH: string;\ndeclare var HMR_SECURE: boolean;\ndeclare var HMR_USE_SSE: boolean;\ndeclare var chrome: ExtensionContext;\ndeclare var browser: ExtensionContext;\ndeclare var __parcel__import__: (string) => Promise<void>;\ndeclare var __parcel__importScripts__: (string) => Promise<void>;\ndeclare var globalThis: typeof self;\ndeclare var ServiceWorkerGlobalScope: Object;\n*/\nvar OVERLAY_ID = '__parcel__error__overlay__';\nvar OldModule = module.bundle.Module;\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData[moduleName],\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n  module.bundle.hotData[moduleName] = undefined;\n}\nmodule.bundle.Module = Module;\nmodule.bundle.hotData = {};\nvar checkedAssets /*: {|[string]: boolean|} */, disposedAssets /*: {|[string]: boolean|} */, assetsToDispose /*: Array<[ParcelRequire, string]> */, assetsToAccept /*: Array<[ParcelRequire, string]> */;\nfunction getHostname() {\n  return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');\n}\nfunction getPort() {\n  return HMR_PORT || location.port;\n}\n\n// eslint-disable-next-line no-redeclare\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = getHostname();\n  var port = getPort();\n  var protocol = HMR_SECURE || location.protocol == 'https:' && !['localhost', '127.0.0.1', '0.0.0.0'].includes(hostname) ? 'wss' : 'ws';\n  var ws;\n  if (HMR_USE_SSE) {\n    ws = new EventSource('/__parcel_hmr');\n  } else {\n    try {\n      ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');\n    } catch (err) {\n      if (err.message) {\n        console.error(err.message);\n      }\n      ws = {};\n    }\n  }\n\n  // Web extension context\n  var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;\n\n  // Safari doesn't support sourceURL in error stacks.\n  // eval may also be disabled via CSP, so do a quick check.\n  var supportsSourceURL = false;\n  try {\n    (0, eval)('throw new Error(\"test\"); //# sourceURL=test.js');\n  } catch (err) {\n    supportsSourceURL = err.stack.includes('test.js');\n  }\n\n  // $FlowFixMe\n  ws.onmessage = async function (event /*: {data: string, ...} */) {\n    checkedAssets = {} /*: {|[string]: boolean|} */;\n    disposedAssets = {} /*: {|[string]: boolean|} */;\n    assetsToAccept = [];\n    assetsToDispose = [];\n    var data /*: HMRMessage */ = JSON.parse(event.data);\n    if (data.type === 'reload') {\n      fullReload();\n    } else if (data.type === 'update') {\n      // Remove error overlay if there is one\n      if (typeof document !== 'undefined') {\n        removeErrorOverlay();\n      }\n      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH);\n\n      // Handle HMR Update\n      let handled = assets.every(asset => {\n        return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);\n      });\n      if (handled) {\n        console.clear();\n\n        // Dispatch custom event so other runtimes (e.g React Refresh) are aware.\n        if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') {\n          window.dispatchEvent(new CustomEvent('parcelhmraccept'));\n        }\n        await hmrApplyUpdates(assets);\n        hmrDisposeQueue();\n\n        // Run accept callbacks. This will also re-execute other disposed assets in topological order.\n        let processedAssets = {};\n        for (let i = 0; i < assetsToAccept.length; i++) {\n          let id = assetsToAccept[i][1];\n          if (!processedAssets[id]) {\n            hmrAccept(assetsToAccept[i][0], id);\n            processedAssets[id] = true;\n          }\n        }\n      } else fullReload();\n    }\n    if (data.type === 'error') {\n      // Log parcel errors to console\n      for (let ansiDiagnostic of data.diagnostics.ansi) {\n        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;\n        console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\\n' + stack + '\\n\\n' + ansiDiagnostic.hints.join('\\n'));\n      }\n      if (typeof document !== 'undefined') {\n        // Render the fancy html overlay\n        removeErrorOverlay();\n        var overlay = createErrorOverlay(data.diagnostics.html);\n        // $FlowFixMe\n        document.body.appendChild(overlay);\n      }\n    }\n  };\n  if (ws instanceof WebSocket) {\n    ws.onerror = function (e) {\n      if (e.message) {\n        console.error(e.message);\n      }\n    };\n    ws.onclose = function () {\n      console.warn('[parcel] 🚨 Connection to the HMR server was lost');\n    };\n  }\n}\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n    console.log('[parcel] ✨ Error resolved');\n  }\n}\nfunction createErrorOverlay(diagnostics) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n  let errorHTML = '<div style=\"background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;\">';\n  for (let diagnostic of diagnostics) {\n    let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame) => {\n      return `${p}\n<a href=\"/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}\" style=\"text-decoration: underline; color: #888\" onclick=\"fetch(this.href); return false\">${frame.location}</a>\n${frame.code}`;\n    }, '') : diagnostic.stack;\n    errorHTML += `\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          🚨 ${diagnostic.message}\n        </div>\n        <pre>${stack}</pre>\n        <div>\n          ${diagnostic.hints.map(hint => '<div>💡 ' + hint + '</div>').join('')}\n        </div>\n        ${diagnostic.documentation ? `<div>📝 <a style=\"color: violet\" href=\"${diagnostic.documentation}\" target=\"_blank\">Learn more</a></div>` : ''}\n      </div>\n    `;\n  }\n  errorHTML += '</div>';\n  overlay.innerHTML = errorHTML;\n  return overlay;\n}\nfunction fullReload() {\n  if ('reload' in location) {\n    location.reload();\n  } else if (extCtx && extCtx.runtime && extCtx.runtime.reload) {\n    extCtx.runtime.reload();\n  }\n}\nfunction getParents(bundle, id) /*: Array<[ParcelRequire, string]> */{\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n  var parents = [];\n  var k, d, dep;\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {\n        parents.push([bundle, k]);\n      }\n    }\n  }\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n  return parents;\n}\nfunction updateLink(link) {\n  var href = link.getAttribute('href');\n  if (!href) {\n    return;\n  }\n  var newLink = link.cloneNode();\n  newLink.onload = function () {\n    if (link.parentNode !== null) {\n      // $FlowFixMe\n      link.parentNode.removeChild(link);\n    }\n  };\n  newLink.setAttribute('href',\n  // $FlowFixMe\n  href.split('?')[0] + '?' + Date.now());\n  // $FlowFixMe\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\nvar cssTimeout = null;\nfunction reloadCSS() {\n  if (cssTimeout) {\n    return;\n  }\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n    for (var i = 0; i < links.length; i++) {\n      // $FlowFixMe[incompatible-type]\n      var href /*: string */ = links[i].getAttribute('href');\n      var hostname = getHostname();\n      var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\\\/\\\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());\n      var absolute = /^https?:\\/\\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;\n      if (!absolute) {\n        updateLink(links[i]);\n      }\n    }\n    cssTimeout = null;\n  }, 50);\n}\nfunction hmrDownload(asset) {\n  if (asset.type === 'js') {\n    if (typeof document !== 'undefined') {\n      let script = document.createElement('script');\n      script.src = asset.url + '?t=' + Date.now();\n      if (asset.outputFormat === 'esmodule') {\n        script.type = 'module';\n      }\n      return new Promise((resolve, reject) => {\n        var _document$head;\n        script.onload = () => resolve(script);\n        script.onerror = reject;\n        (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);\n      });\n    } else if (typeof importScripts === 'function') {\n      // Worker scripts\n      if (asset.outputFormat === 'esmodule') {\n        return __parcel__import__(asset.url + '?t=' + Date.now());\n      } else {\n        return new Promise((resolve, reject) => {\n          try {\n            __parcel__importScripts__(asset.url + '?t=' + Date.now());\n            resolve();\n          } catch (err) {\n            reject(err);\n          }\n        });\n      }\n    }\n  }\n}\nasync function hmrApplyUpdates(assets) {\n  global.parcelHotUpdate = Object.create(null);\n  let scriptsToRemove;\n  try {\n    // If sourceURL comments aren't supported in eval, we need to load\n    // the update from the dev server over HTTP so that stack traces\n    // are correct in errors/logs. This is much slower than eval, so\n    // we only do it if needed (currently just Safari).\n    // https://bugs.webkit.org/show_bug.cgi?id=137297\n    // This path is also taken if a CSP disallows eval.\n    if (!supportsSourceURL) {\n      let promises = assets.map(asset => {\n        var _hmrDownload;\n        return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch(err => {\n          // Web extension fix\n          if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {\n            extCtx.runtime.reload();\n            return;\n          }\n          throw err;\n        });\n      });\n      scriptsToRemove = await Promise.all(promises);\n    }\n    assets.forEach(function (asset) {\n      hmrApply(module.bundle.root, asset);\n    });\n  } finally {\n    delete global.parcelHotUpdate;\n    if (scriptsToRemove) {\n      scriptsToRemove.forEach(script => {\n        if (script) {\n          var _document$head2;\n          (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);\n        }\n      });\n    }\n  }\n}\nfunction hmrApply(bundle /*: ParcelRequire */, asset /*:  HMRAsset */) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (asset.type === 'css') {\n    reloadCSS();\n  } else if (asset.type === 'js') {\n    let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];\n    if (deps) {\n      if (modules[asset.id]) {\n        // Remove dependencies that are removed and will become orphaned.\n        // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.\n        let oldDeps = modules[asset.id][1];\n        for (let dep in oldDeps) {\n          if (!deps[dep] || deps[dep] !== oldDeps[dep]) {\n            let id = oldDeps[dep];\n            let parents = getParents(module.bundle.root, id);\n            if (parents.length === 1) {\n              hmrDelete(module.bundle.root, id);\n            }\n          }\n        }\n      }\n      if (supportsSourceURL) {\n        // Global eval. We would use `new Function` here but browser\n        // support for source maps is better with eval.\n        (0, eval)(asset.output);\n      }\n\n      // $FlowFixMe\n      let fn = global.parcelHotUpdate[asset.id];\n      modules[asset.id] = [fn, deps];\n    }\n\n    // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.\n    // This is required in case modules are duplicated. We need to ensure all instances have the updated code.\n    if (bundle.parent) {\n      hmrApply(bundle.parent, asset);\n    }\n  }\n}\nfunction hmrDelete(bundle, id) {\n  let modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (modules[id]) {\n    // Collect dependencies that will become orphaned when this module is deleted.\n    let deps = modules[id][1];\n    let orphans = [];\n    for (let dep in deps) {\n      let parents = getParents(module.bundle.root, deps[dep]);\n      if (parents.length === 1) {\n        orphans.push(deps[dep]);\n      }\n    }\n\n    // Delete the module. This must be done before deleting dependencies in case of circular dependencies.\n    delete modules[id];\n    delete bundle.cache[id];\n\n    // Now delete the orphans.\n    orphans.forEach(id => {\n      hmrDelete(module.bundle.root, id);\n    });\n  } else if (bundle.parent) {\n    hmrDelete(bundle.parent, id);\n  }\n}\nfunction hmrAcceptCheck(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  if (hmrAcceptCheckOne(bundle, id, depsByBundle)) {\n    return true;\n  }\n\n  // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.\n  let parents = getParents(module.bundle.root, id);\n  let accepted = false;\n  while (parents.length > 0) {\n    let v = parents.shift();\n    let a = hmrAcceptCheckOne(v[0], v[1], null);\n    if (a) {\n      // If this parent accepts, stop traversing upward, but still consider siblings.\n      accepted = true;\n    } else {\n      // Otherwise, queue the parents in the next level upward.\n      let p = getParents(module.bundle.root, v[1]);\n      if (p.length === 0) {\n        // If there are no parents, then we've reached an entry without accepting. Reload.\n        accepted = false;\n        break;\n      }\n      parents.push(...p);\n    }\n  }\n  return accepted;\n}\nfunction hmrAcceptCheckOne(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {\n    // If we reached the root bundle without finding where the asset should go,\n    // there's nothing to do. Mark as \"accepted\" so we don't reload the page.\n    if (!bundle.parent) {\n      return true;\n    }\n    return hmrAcceptCheck(bundle.parent, id, depsByBundle);\n  }\n  if (checkedAssets[id]) {\n    return true;\n  }\n  checkedAssets[id] = true;\n  var cached = bundle.cache[id];\n  assetsToDispose.push([bundle, id]);\n  if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {\n    assetsToAccept.push([bundle, id]);\n    return true;\n  }\n}\nfunction hmrDisposeQueue() {\n  // Dispose all old assets.\n  for (let i = 0; i < assetsToDispose.length; i++) {\n    let id = assetsToDispose[i][1];\n    if (!disposedAssets[id]) {\n      hmrDispose(assetsToDispose[i][0], id);\n      disposedAssets[id] = true;\n    }\n  }\n  assetsToDispose = [];\n}\nfunction hmrDispose(bundle /*: ParcelRequire */, id /*: string */) {\n  var cached = bundle.cache[id];\n  bundle.hotData[id] = {};\n  if (cached && cached.hot) {\n    cached.hot.data = bundle.hotData[id];\n  }\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData[id]);\n    });\n  }\n  delete bundle.cache[id];\n}\nfunction hmrAccept(bundle /*: ParcelRequire */, id /*: string */) {\n  // Execute the module.\n  bundle(id);\n\n  // Run the accept callbacks in the new version of the module.\n  var cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    let assetsToAlsoAccept = [];\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      let additionalAssets = cb(function () {\n        return getParents(module.bundle.root, id);\n      });\n      if (Array.isArray(additionalAssets) && additionalAssets.length) {\n        assetsToAlsoAccept.push(...additionalAssets);\n      }\n    });\n    if (assetsToAlsoAccept.length) {\n      let handled = assetsToAlsoAccept.every(function (a) {\n        return hmrAcceptCheck(a[0], a[1]);\n      });\n      if (!handled) {\n        return fullReload();\n      }\n      hmrDisposeQueue();\n    }\n  }\n}","import { useStopwatch } from 'react-timer-hook';\r\nimport { render } from 'preact';\r\n\r\n\r\nfunction MyStopwatch() {\r\n  const {\r\n    seconds,\r\n    minutes,\r\n    hours,\r\n    days\r\n  } = useStopwatch({ autoStart: true, interval:20 });\r\n\r\n  return (\r\n      <div><span>{days}</span>d <span>{hours}</span>h <span>{minutes}</span>m <span>{seconds}</span>s</div>\r\n  );\r\n}\r\n\r\nconst timer = document.getElementById('timer');\r\nrender(<MyStopwatch />, timer)","require('preact/compat');\n\nmodule.exports = require('preact/jsx-runtime');\n",null,"/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nexport function shallowDiffers(a, b) {\n\tfor (let i in a) if (i !== '__source' && !(i in b)) return true;\n\tfor (let i in b) if (i !== '__source' && a[i] !== b[i]) return true;\n\treturn false;\n}\n\n/**\n * Check if two values are the same value\n * @param {*} x\n * @param {*} y\n * @returns {boolean}\n */\nexport function is(x, y) {\n\treturn (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\n","import { useState, useLayoutEffect, useEffect } from 'preact/hooks';\nimport { is } from './util';\n\n/**\n * This is taken from https://github.com/facebook/react/blob/main/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js#L84\n * on a high level this cuts out the warnings, ... and attempts a smaller implementation\n * @typedef {{ _value: any; _getSnapshot: () => any }} Store\n */\nexport function useSyncExternalStore(subscribe, getSnapshot) {\n\tconst value = getSnapshot();\n\n\t/**\n\t * @typedef {{ _instance: Store }} StoreRef\n\t * @type {[StoreRef, (store: StoreRef) => void]}\n\t */\n\tconst [{ _instance }, forceUpdate] = useState({\n\t\t_instance: { _value: value, _getSnapshot: getSnapshot }\n\t});\n\n\tuseLayoutEffect(() => {\n\t\t_instance._value = value;\n\t\t_instance._getSnapshot = getSnapshot;\n\n\t\tif (didSnapshotChange(_instance)) {\n\t\t\tforceUpdate({ _instance });\n\t\t}\n\t}, [subscribe, value, getSnapshot]);\n\n\tuseEffect(() => {\n\t\tif (didSnapshotChange(_instance)) {\n\t\t\tforceUpdate({ _instance });\n\t\t}\n\n\t\treturn subscribe(() => {\n\t\t\tif (didSnapshotChange(_instance)) {\n\t\t\t\tforceUpdate({ _instance });\n\t\t\t}\n\t\t});\n\t}, [subscribe]);\n\n\treturn value;\n}\n\n/** @type {(inst: Store) => boolean} */\nfunction didSnapshotChange(inst) {\n\tconst latestGetSnapshot = inst._getSnapshot;\n\tconst prevValue = inst._value;\n\ttry {\n\t\tconst nextValue = latestGetSnapshot();\n\t\treturn !is(prevValue, nextValue);\n\t} catch (error) {\n\t\treturn true;\n\t}\n}\n\nexport function startTransition(cb) {\n\tcb();\n}\n\nexport function useDeferredValue(val) {\n\treturn val;\n}\n\nexport function useTransition() {\n\treturn [false, startTransition];\n}\n\n// TODO: in theory this should be done after a VNode is diffed as we want to insert\n// styles/... before it attaches\nexport const useInsertionEffect = useLayoutEffect;\n","import { Component } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nexport function PureComponent(p, c) {\n\tthis.props = p;\n\tthis.context = c;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function (props, state) {\n\treturn shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n","import { createElement } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionComponent}\n */\nexport function memo(c, comparer) {\n\tfunction shouldUpdate(nextProps) {\n\t\tlet ref = this.props.ref;\n\t\tlet updateRef = ref == nextProps.ref;\n\t\tif (!updateRef && ref) {\n\t\t\tref.call ? ref(null) : (ref.current = null);\n\t\t}\n\n\t\tif (!comparer) {\n\t\t\treturn shallowDiffers(this.props, nextProps);\n\t\t}\n\n\t\treturn !comparer(this.props, nextProps) || !updateRef;\n\t}\n\n\tfunction Memoed(props) {\n\t\tthis.shouldComponentUpdate = shouldUpdate;\n\t\treturn createElement(c, props);\n\t}\n\tMemoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n\tMemoed.prototype.isReactComponent = true;\n\tMemoed._forwarded = true;\n\treturn Memoed;\n}\n","import { options } from 'preact';\nimport { assign } from './util';\n\nlet oldDiffHook = options._diff;\noptions._diff = vnode => {\n\tif (vnode.type && vnode.type._forwarded && vnode.ref) {\n\t\tvnode.props.ref = vnode.ref;\n\t\tvnode.ref = null;\n\t}\n\tif (oldDiffHook) oldDiffHook(vnode);\n};\n\nexport const REACT_FORWARD_SYMBOL =\n\t(typeof Symbol != 'undefined' &&\n\t\tSymbol.for &&\n\t\tSymbol.for('react.forward_ref')) ||\n\t0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionComponent}\n */\nexport function forwardRef(fn) {\n\tfunction Forwarded(props) {\n\t\tlet clone = assign({}, props);\n\t\tdelete clone.ref;\n\t\treturn fn(clone, props.ref || null);\n\t}\n\n\t// mobx-react checks for this being present\n\tForwarded.$$typeof = REACT_FORWARD_SYMBOL;\n\t// mobx-react heavily relies on implementation details.\n\t// It expects an object here with a `render` property,\n\t// and prototype.render will fail. Without this\n\t// mobx-react throws.\n\tForwarded.render = Forwarded;\n\n\tForwarded.prototype.isReactComponent = Forwarded._forwarded = true;\n\tForwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n\treturn Forwarded;\n}\n","import { toChildArray } from 'preact';\n\nconst mapFn = (children, fn) => {\n\tif (children == null) return null;\n\treturn toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nexport const Children = {\n\tmap: mapFn,\n\tforEach: mapFn,\n\tcount(children) {\n\t\treturn children ? toChildArray(children).length : 0;\n\t},\n\tonly(children) {\n\t\tconst normalized = toChildArray(children);\n\t\tif (normalized.length !== 1) throw 'Children.only';\n\t\treturn normalized[0];\n\t},\n\ttoArray: toChildArray\n};\n","import { Component, createElement, options, Fragment } from 'preact';\nimport { MODE_HYDRATE } from '../../src/constants';\nimport { assign } from './util';\n\nconst oldCatchError = options._catchError;\noptions._catchError = function (error, newVNode, oldVNode, errorInfo) {\n\tif (error.then) {\n\t\t/** @type {import('./internal').Component} */\n\t\tlet component;\n\t\tlet vnode = newVNode;\n\n\t\tfor (; (vnode = vnode._parent); ) {\n\t\t\tif ((component = vnode._component) && component._childDidSuspend) {\n\t\t\t\tif (newVNode._dom == null) {\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t}\n\t\t\t\t// Don't call oldCatchError if we found a Suspense\n\t\t\t\treturn component._childDidSuspend(error, newVNode);\n\t\t\t}\n\t\t}\n\t}\n\toldCatchError(error, newVNode, oldVNode, errorInfo);\n};\n\nconst oldUnmount = options.unmount;\noptions.unmount = function (vnode) {\n\t/** @type {import('./internal').Component} */\n\tconst component = vnode._component;\n\tif (component && component._onResolve) {\n\t\tcomponent._onResolve();\n\t}\n\n\t// if the component is still hydrating\n\t// most likely it is because the component is suspended\n\t// we set the vnode.type as `null` so that it is not a typeof function\n\t// so the unmount will remove the vnode._dom\n\tif (component && vnode._flags & MODE_HYDRATE) {\n\t\tvnode.type = null;\n\t}\n\n\tif (oldUnmount) oldUnmount(vnode);\n};\n\nfunction detachedClone(vnode, detachedParent, parentDom) {\n\tif (vnode) {\n\t\tif (vnode._component && vnode._component.__hooks) {\n\t\t\tvnode._component.__hooks._list.forEach(effect => {\n\t\t\t\tif (typeof effect._cleanup == 'function') effect._cleanup();\n\t\t\t});\n\n\t\t\tvnode._component.__hooks = null;\n\t\t}\n\n\t\tvnode = assign({}, vnode);\n\t\tif (vnode._component != null) {\n\t\t\tif (vnode._component._parentDom === parentDom) {\n\t\t\t\tvnode._component._parentDom = detachedParent;\n\t\t\t}\n\t\t\tvnode._component = null;\n\t\t}\n\n\t\tvnode._children =\n\t\t\tvnode._children &&\n\t\t\tvnode._children.map(child =>\n\t\t\t\tdetachedClone(child, detachedParent, parentDom)\n\t\t\t);\n\t}\n\n\treturn vnode;\n}\n\nfunction removeOriginal(vnode, detachedParent, originalParent) {\n\tif (vnode && originalParent) {\n\t\tvnode._original = null;\n\t\tvnode._children =\n\t\t\tvnode._children &&\n\t\t\tvnode._children.map(child =>\n\t\t\t\tremoveOriginal(child, detachedParent, originalParent)\n\t\t\t);\n\n\t\tif (vnode._component) {\n\t\t\tif (vnode._component._parentDom === detachedParent) {\n\t\t\t\tif (vnode._dom) {\n\t\t\t\t\toriginalParent.appendChild(vnode._dom);\n\t\t\t\t}\n\t\t\t\tvnode._component._force = true;\n\t\t\t\tvnode._component._parentDom = originalParent;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nexport function Suspense() {\n\t// we do not call super here to golf some bytes...\n\tthis._pendingSuspensionCount = 0;\n\tthis._suspenders = null;\n\tthis._detachOnNextRender = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {Promise} promise The thrown promise\n * @param {import('./internal').VNode<any, any>} suspendingVNode The suspending component\n */\nSuspense.prototype._childDidSuspend = function (promise, suspendingVNode) {\n\tconst suspendingComponent = suspendingVNode._component;\n\n\t/** @type {import('./internal').SuspenseComponent} */\n\tconst c = this;\n\n\tif (c._suspenders == null) {\n\t\tc._suspenders = [];\n\t}\n\tc._suspenders.push(suspendingComponent);\n\n\tconst resolve = suspended(c._vnode);\n\n\tlet resolved = false;\n\tconst onResolved = () => {\n\t\tif (resolved) return;\n\n\t\tresolved = true;\n\t\tsuspendingComponent._onResolve = null;\n\n\t\tif (resolve) {\n\t\t\tresolve(onSuspensionComplete);\n\t\t} else {\n\t\t\tonSuspensionComplete();\n\t\t}\n\t};\n\n\tsuspendingComponent._onResolve = onResolved;\n\n\tconst onSuspensionComplete = () => {\n\t\tif (!--c._pendingSuspensionCount) {\n\t\t\t// If the suspension was during hydration we don't need to restore the\n\t\t\t// suspended children into the _children array\n\t\t\tif (c.state._suspended) {\n\t\t\t\tconst suspendedVNode = c.state._suspended;\n\t\t\t\tc._vnode._children[0] = removeOriginal(\n\t\t\t\t\tsuspendedVNode,\n\t\t\t\t\tsuspendedVNode._component._parentDom,\n\t\t\t\t\tsuspendedVNode._component._originalParentDom\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tc.setState({ _suspended: (c._detachOnNextRender = null) });\n\n\t\t\tlet suspended;\n\t\t\twhile ((suspended = c._suspenders.pop())) {\n\t\t\t\tsuspended.forceUpdate();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * We do not set `suspended: true` during hydration because we want the actual markup\n\t * to remain on screen and hydrate it when the suspense actually gets resolved.\n\t * While in non-hydration cases the usual fallback -> component flow would occour.\n\t */\n\tif (\n\t\t!c._pendingSuspensionCount++ &&\n\t\t!(suspendingVNode._flags & MODE_HYDRATE)\n\t) {\n\t\tc.setState({ _suspended: (c._detachOnNextRender = c._vnode._children[0]) });\n\t}\n\tpromise.then(onResolved, onResolved);\n};\n\nSuspense.prototype.componentWillUnmount = function () {\n\tthis._suspenders = [];\n};\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {import('./internal').SuspenseComponent[\"props\"]} props\n * @param {import('./internal').SuspenseState} state\n */\nSuspense.prototype.render = function (props, state) {\n\tif (this._detachOnNextRender) {\n\t\t// When the Suspense's _vnode was created by a call to createVNode\n\t\t// (i.e. due to a setState further up in the tree)\n\t\t// it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n\t\tif (this._vnode._children) {\n\t\t\tconst detachedParent = document.createElement('div');\n\t\t\tconst detachedComponent = this._vnode._children[0]._component;\n\t\t\tthis._vnode._children[0] = detachedClone(\n\t\t\t\tthis._detachOnNextRender,\n\t\t\t\tdetachedParent,\n\t\t\t\t(detachedComponent._originalParentDom = detachedComponent._parentDom)\n\t\t\t);\n\t\t}\n\n\t\tthis._detachOnNextRender = null;\n\t}\n\n\t// Wrap fallback tree in a VNode that prevents itself from being marked as aborting mid-hydration:\n\t/** @type {import('./internal').VNode} */\n\tconst fallback =\n\t\tstate._suspended && createElement(Fragment, null, props.fallback);\n\tif (fallback) fallback._flags &= ~MODE_HYDRATE;\n\n\treturn [\n\t\tcreateElement(Fragment, null, state._suspended ? null : props.children),\n\t\tfallback\n\t];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('./internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nexport function suspended(vnode) {\n\t/** @type {import('./internal').Component} */\n\tlet component = vnode._parent._component;\n\treturn component && component._suspended && component._suspended(vnode);\n}\n\nexport function lazy(loader) {\n\tlet prom;\n\tlet component;\n\tlet error;\n\n\tfunction Lazy(props) {\n\t\tif (!prom) {\n\t\t\tprom = loader();\n\t\t\tprom.then(\n\t\t\t\texports => {\n\t\t\t\t\tcomponent = exports.default || exports;\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\terror = e;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!component) {\n\t\t\tthrow prom;\n\t\t}\n\n\t\treturn createElement(component, props);\n\t}\n\n\tLazy.displayName = 'Lazy';\n\tLazy._forwarded = true;\n\treturn Lazy;\n}\n","import { Component, toChildArray } from 'preact';\nimport { suspended } from './suspense.js';\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nconst SUSPENDED_COUNT = 0;\nconst RESOLVED_COUNT = 1;\nconst NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nexport function SuspenseList() {\n\tthis._next = null;\n\tthis._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nconst resolve = (list, child, node) => {\n\tif (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n\t\t// The number a child (or any of its descendants) has been suspended\n\t\t// matches the number of times it's been resolved. Therefore we\n\t\t// mark the child as completely resolved by deleting it from ._map.\n\t\t// This is used to figure out when *all* children have been completely\n\t\t// resolved when revealOrder is 'together'.\n\t\tlist._map.delete(child);\n\t}\n\n\t// If revealOrder is falsy then we can do an early exit, as the\n\t// callbacks won't get queued in the node anyway.\n\t// If revealOrder is 'together' then also do an early exit\n\t// if all suspended descendants have not yet been resolved.\n\tif (\n\t\t!list.props.revealOrder ||\n\t\t(list.props.revealOrder[0] === 't' && list._map.size)\n\t) {\n\t\treturn;\n\t}\n\n\t// Walk the currently suspended children in order, calling their\n\t// stored callbacks on the way. Stop if we encounter a child that\n\t// has not been completely resolved yet.\n\tnode = list._next;\n\twhile (node) {\n\t\twhile (node.length > 3) {\n\t\t\tnode.pop()();\n\t\t}\n\t\tif (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n\t\t\tbreak;\n\t\t}\n\t\tlist._next = node = node[NEXT_NODE];\n\t}\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\n\nSuspenseList.prototype._suspended = function (child) {\n\tconst list = this;\n\tconst delegated = suspended(list._vnode);\n\n\tlet node = list._map.get(child);\n\tnode[SUSPENDED_COUNT]++;\n\n\treturn unsuspend => {\n\t\tconst wrappedUnsuspend = () => {\n\t\t\tif (!list.props.revealOrder) {\n\t\t\t\t// Special case the undefined (falsy) revealOrder, as there\n\t\t\t\t// is no need to coordinate a specific order or unsuspends.\n\t\t\t\tunsuspend();\n\t\t\t} else {\n\t\t\t\tnode.push(unsuspend);\n\t\t\t\tresolve(list, child, node);\n\t\t\t}\n\t\t};\n\t\tif (delegated) {\n\t\t\tdelegated(wrappedUnsuspend);\n\t\t} else {\n\t\t\twrappedUnsuspend();\n\t\t}\n\t};\n};\n\nSuspenseList.prototype.render = function (props) {\n\tthis._next = null;\n\tthis._map = new Map();\n\n\tconst children = toChildArray(props.children);\n\tif (props.revealOrder && props.revealOrder[0] === 'b') {\n\t\t// If order === 'backwards' (or, well, anything starting with a 'b')\n\t\t// then flip the child list around so that the last child will be\n\t\t// the first in the linked list.\n\t\tchildren.reverse();\n\t}\n\t// Build the linked list. Iterate through the children in reverse order\n\t// so that `_next` points to the first linked list node to be resolved.\n\tfor (let i = children.length; i--; ) {\n\t\t// Create a new linked list node as an array of form:\n\t\t// \t[suspended_count, resolved_count, next_node]\n\t\t// where suspended_count and resolved_count are numeric counters for\n\t\t// keeping track how many times a node has been suspended and resolved.\n\t\t//\n\t\t// Note that suspended_count starts from 1 instead of 0, so we can block\n\t\t// processing callbacks until componentDidMount has been called. In a sense\n\t\t// node is suspended at least until componentDidMount gets called!\n\t\t//\n\t\t// Pending callbacks are added to the end of the node:\n\t\t// \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n\t\tthis._map.set(children[i], (this._next = [1, 0, this._next]));\n\t}\n\treturn props.children;\n};\n\nSuspenseList.prototype.componentDidUpdate =\n\tSuspenseList.prototype.componentDidMount = function () {\n\t\t// Iterate through all children after mounting for two reasons:\n\t\t// 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n\t\t//    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n\t\t//    The nodes can now be completely consumed from the linked list.\n\t\t// 2. Handle nodes that might have gotten resolved between render and\n\t\t//    componentDidMount.\n\t\tthis._map.forEach((node, child) => {\n\t\t\tresolve(this, child, node);\n\t\t});\n\t};\n","/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 2;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 1;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexport const XHTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\nexport const NULL = null;\nexport const UNDEFINED = undefined;\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","import { createElement, render } from 'preact';\n\n/**\n * @param {import('../../src/index').RenderableProps<{ context: any }>} props\n */\nfunction ContextProvider(props) {\n\tthis.getChildContext = () => props.context;\n\treturn props.children;\n}\n\n/**\n * Portal component\n * @this {import('./internal').Component}\n * @param {object | null | undefined} props\n *\n * TODO: use createRoot() instead of fake root\n */\nfunction Portal(props) {\n\tconst _this = this;\n\tlet container = props._container;\n\n\t_this.componentWillUnmount = function () {\n\t\trender(null, _this._temp);\n\t\t_this._temp = null;\n\t\t_this._container = null;\n\t};\n\n\t// When we change container we should clear our old container and\n\t// indicate a new mount.\n\tif (_this._container && _this._container !== container) {\n\t\t_this.componentWillUnmount();\n\t}\n\n\tif (!_this._temp) {\n\t\t_this._container = container;\n\n\t\t// Create a fake DOM parent node that manages a subset of `container`'s children:\n\t\t_this._temp = {\n\t\t\tnodeType: 1,\n\t\t\tparentNode: container,\n\t\t\tchildNodes: [],\n\t\t\tcontains: () => true,\n\t\t\t// Technically this isn't needed\n\t\t\tappendChild(child) {\n\t\t\t\tthis.childNodes.push(child);\n\t\t\t\t_this._container.appendChild(child);\n\t\t\t},\n\t\t\tinsertBefore(child, before) {\n\t\t\t\tthis.childNodes.push(child);\n\t\t\t\t_this._container.insertBefore(child, before);\n\t\t\t},\n\t\t\tremoveChild(child) {\n\t\t\t\tthis.childNodes.splice(this.childNodes.indexOf(child) >>> 1, 1);\n\t\t\t\t_this._container.removeChild(child);\n\t\t\t}\n\t\t};\n\t}\n\n\t// Render our wrapping element into temp.\n\trender(\n\t\tcreateElement(ContextProvider, { context: _this.context }, props._vnode),\n\t\t_this._temp\n\t);\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\tconst el = createElement(Portal, { _vnode: vnode, _container: container });\n\tel.containerInfo = container;\n\treturn el;\n}\n","import {\n\trender as preactRender,\n\thydrate as preactHydrate,\n\toptions,\n\ttoChildArray,\n\tComponent\n} from 'preact';\nimport {\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tuseEffect,\n\tuseId,\n\tuseImperativeHandle,\n\tuseLayoutEffect,\n\tuseMemo,\n\tuseReducer,\n\tuseRef,\n\tuseState\n} from 'preact/hooks';\nimport {\n\tuseDeferredValue,\n\tuseInsertionEffect,\n\tuseSyncExternalStore,\n\tuseTransition\n} from './index';\n\nexport const REACT_ELEMENT_TYPE =\n\t(typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element')) ||\n\t0xeac7;\n\nconst CAMEL_PROPS =\n\t/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;\nconst ON_ANI = /^on(Ani|Tra|Tou|BeforeInp|Compo)/;\nconst CAMEL_REPLACE = /[A-Z0-9]/g;\nconst IS_DOM = typeof document !== 'undefined';\n\n// Input types for which onchange should not be converted to oninput.\n// type=\"file|checkbox|radio\", plus \"range\" in IE11.\n// (IE11 doesn't support Symbol, which we use here to turn `rad` into `ra` which matches \"range\")\nconst onChangeInputType = type =>\n\t(typeof Symbol != 'undefined' && typeof Symbol() == 'symbol'\n\t\t? /fil|che|rad/\n\t\t: /fil|che|ra/\n\t).test(type);\n\n// Some libraries like `react-virtualized` explicitly check for this.\nComponent.prototype.isReactComponent = {};\n\n// `UNSAFE_*` lifecycle hooks\n// Preact only ever invokes the unprefixed methods.\n// Here we provide a base \"fallback\" implementation that calls any defined UNSAFE_ prefixed method.\n// - If a component defines its own `componentDidMount()` (including via defineProperty), use that.\n// - If a component defines `UNSAFE_componentDidMount()`, `componentDidMount` is the alias getter/setter.\n// - If anything assigns to an `UNSAFE_*` property, the assignment is forwarded to the unprefixed property.\n// See https://github.com/preactjs/preact/issues/1941\n[\n\t'componentWillMount',\n\t'componentWillReceiveProps',\n\t'componentWillUpdate'\n].forEach(key => {\n\tObject.defineProperty(Component.prototype, key, {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn this['UNSAFE_' + key];\n\t\t},\n\t\tset(v) {\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: v\n\t\t\t});\n\t\t}\n\t});\n});\n\n/**\n * Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null\n */\nexport function render(vnode, parent, callback) {\n\t// React destroys any existing DOM nodes, see #1727\n\t// ...but only on the first render, see #1828\n\tif (parent._children == null) {\n\t\tparent.textContent = '';\n\t}\n\n\tpreactRender(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nexport function hydrate(vnode, parent, callback) {\n\tpreactHydrate(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nlet oldEventHook = options.event;\noptions.event = e => {\n\tif (oldEventHook) e = oldEventHook(e);\n\n\te.persist = empty;\n\te.isPropagationStopped = isPropagationStopped;\n\te.isDefaultPrevented = isDefaultPrevented;\n\treturn (e.nativeEvent = e);\n};\n\nfunction empty() {}\n\nfunction isPropagationStopped() {\n\treturn this.cancelBubble;\n}\n\nfunction isDefaultPrevented() {\n\treturn this.defaultPrevented;\n}\n\nconst classNameDescriptorNonEnumberable = {\n\tenumerable: false,\n\tconfigurable: true,\n\tget() {\n\t\treturn this.class;\n\t}\n};\n\nfunction handleDomVNode(vnode) {\n\tlet props = vnode.props,\n\t\ttype = vnode.type,\n\t\tnormalizedProps = {};\n\n\tlet isNonDashedType = type.indexOf('-') === -1;\n\tfor (let i in props) {\n\t\tlet value = props[i];\n\n\t\tif (\n\t\t\t(i === 'value' && 'defaultValue' in props && value == null) ||\n\t\t\t// Emulate React's behavior of not rendering the contents of noscript tags on the client.\n\t\t\t(IS_DOM && i === 'children' && type === 'noscript') ||\n\t\t\ti === 'class' ||\n\t\t\ti === 'className'\n\t\t) {\n\t\t\t// Skip applying value if it is null/undefined and we already set\n\t\t\t// a default value\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet lowerCased = i.toLowerCase();\n\t\tif (i === 'defaultValue' && 'value' in props && props.value == null) {\n\t\t\t// `defaultValue` is treated as a fallback `value` when a value prop is present but null/undefined.\n\t\t\t// `defaultValue` for Elements with no value prop is the same as the DOM defaultValue property.\n\t\t\ti = 'value';\n\t\t} else if (i === 'download' && value === true) {\n\t\t\t// Calling `setAttribute` with a truthy value will lead to it being\n\t\t\t// passed as a stringified value, e.g. `download=\"true\"`. React\n\t\t\t// converts it to an empty string instead, otherwise the attribute\n\t\t\t// value will be used as the file name and the file will be called\n\t\t\t// \"true\" upon downloading it.\n\t\t\tvalue = '';\n\t\t} else if (lowerCased === 'translate' && value === 'no') {\n\t\t\tvalue = false;\n\t\t} else if (lowerCased[0] === 'o' && lowerCased[1] === 'n') {\n\t\t\tif (lowerCased === 'ondoubleclick') {\n\t\t\t\ti = 'ondblclick';\n\t\t\t} else if (\n\t\t\t\tlowerCased === 'onchange' &&\n\t\t\t\t(type === 'input' || type === 'textarea') &&\n\t\t\t\t!onChangeInputType(props.type)\n\t\t\t) {\n\t\t\t\tlowerCased = i = 'oninput';\n\t\t\t} else if (lowerCased === 'onfocus') {\n\t\t\t\ti = 'onfocusin';\n\t\t\t} else if (lowerCased === 'onblur') {\n\t\t\t\ti = 'onfocusout';\n\t\t\t} else if (ON_ANI.test(i)) {\n\t\t\t\ti = lowerCased;\n\t\t\t}\n\t\t} else if (isNonDashedType && CAMEL_PROPS.test(i)) {\n\t\t\ti = i.replace(CAMEL_REPLACE, '-$&').toLowerCase();\n\t\t} else if (value === null) {\n\t\t\tvalue = undefined;\n\t\t}\n\n\t\t// Add support for onInput and onChange, see #3561\n\t\t// if we have an oninput prop already change it to oninputCapture\n\t\tif (lowerCased === 'oninput') {\n\t\t\ti = lowerCased;\n\t\t\tif (normalizedProps[i]) {\n\t\t\t\ti = 'oninputCapture';\n\t\t\t}\n\t\t}\n\n\t\tnormalizedProps[i] = value;\n\t}\n\n\t// Add support for array select values: <select multiple value={[]} />\n\tif (\n\t\ttype == 'select' &&\n\t\tnormalizedProps.multiple &&\n\t\tArray.isArray(normalizedProps.value)\n\t) {\n\t\t// forEach() always returns undefined, which we abuse here to unset the value prop.\n\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\tchild.props.selected =\n\t\t\t\tnormalizedProps.value.indexOf(child.props.value) != -1;\n\t\t});\n\t}\n\n\t// Adding support for defaultValue in select tag\n\tif (type == 'select' && normalizedProps.defaultValue != null) {\n\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\tif (normalizedProps.multiple) {\n\t\t\t\tchild.props.selected =\n\t\t\t\t\tnormalizedProps.defaultValue.indexOf(child.props.value) != -1;\n\t\t\t} else {\n\t\t\t\tchild.props.selected =\n\t\t\t\t\tnormalizedProps.defaultValue == child.props.value;\n\t\t\t}\n\t\t});\n\t}\n\n\tif (props.class && !props.className) {\n\t\tnormalizedProps.class = props.class;\n\t\tObject.defineProperty(\n\t\t\tnormalizedProps,\n\t\t\t'className',\n\t\t\tclassNameDescriptorNonEnumberable\n\t\t);\n\t} else if (props.className && !props.class) {\n\t\tnormalizedProps.class = normalizedProps.className = props.className;\n\t} else if (props.class && props.className) {\n\t\tnormalizedProps.class = normalizedProps.className = props.className;\n\t}\n\n\tvnode.props = normalizedProps;\n}\n\nlet oldVNodeHook = options.vnode;\noptions.vnode = vnode => {\n\t// only normalize props on Element nodes\n\tif (typeof vnode.type === 'string') {\n\t\thandleDomVNode(vnode);\n\t}\n\n\tvnode.$$typeof = REACT_ELEMENT_TYPE;\n\n\tif (oldVNodeHook) oldVNodeHook(vnode);\n};\n\n// Only needed for react-relay\nlet currentComponent;\nconst oldBeforeRender = options._render;\noptions._render = function (vnode) {\n\tif (oldBeforeRender) {\n\t\toldBeforeRender(vnode);\n\t}\n\tcurrentComponent = vnode._component;\n};\n\nconst oldDiffed = options.diffed;\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = function (vnode) {\n\tif (oldDiffed) {\n\t\toldDiffed(vnode);\n\t}\n\n\tconst props = vnode.props;\n\tconst dom = vnode._dom;\n\n\tif (\n\t\tdom != null &&\n\t\tvnode.type === 'textarea' &&\n\t\t'value' in props &&\n\t\tprops.value !== dom.value\n\t) {\n\t\tdom.value = props.value == null ? '' : props.value;\n\t}\n\n\tcurrentComponent = null;\n};\n\n// This is a very very private internal function for React it\n// is used to sort-of do runtime dependency injection.\nexport const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {\n\tReactCurrentDispatcher: {\n\t\tcurrent: {\n\t\t\treadContext(context) {\n\t\t\t\treturn currentComponent._globalContext[context._id].props.value;\n\t\t\t},\n\t\t\tuseCallback,\n\t\t\tuseContext,\n\t\t\tuseDebugValue,\n\t\t\tuseDeferredValue,\n\t\t\tuseEffect,\n\t\t\tuseId,\n\t\t\tuseImperativeHandle,\n\t\t\tuseInsertionEffect,\n\t\t\tuseLayoutEffect,\n\t\t\tuseMemo,\n\t\t\t// useMutableSource, // experimental-only and replaced by uSES, likely not worth supporting\n\t\t\tuseReducer,\n\t\t\tuseRef,\n\t\t\tuseState,\n\t\t\tuseSyncExternalStore,\n\t\t\tuseTransition\n\t\t}\n\t}\n};\n","import {\n\tcreateElement,\n\trender as preactRender,\n\tcloneElement as preactCloneElement,\n\tcreateRef,\n\tComponent,\n\tcreateContext,\n\tFragment\n} from 'preact';\nimport {\n\tuseState,\n\tuseId,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue\n} from 'preact/hooks';\nimport {\n\tuseInsertionEffect,\n\tstartTransition,\n\tuseDeferredValue,\n\tuseSyncExternalStore,\n\tuseTransition\n} from './hooks';\nimport { PureComponent } from './PureComponent';\nimport { memo } from './memo';\nimport { forwardRef } from './forwardRef';\nimport { Children } from './Children';\nimport { Suspense, lazy } from './suspense';\nimport { SuspenseList } from './suspense-list';\nimport { createPortal } from './portals';\nimport {\n\thydrate,\n\trender,\n\tREACT_ELEMENT_TYPE,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n} from './render';\n\nconst version = '18.3.1'; // trick libraries to think we are react\n\n/**\n * Legacy version of createElement.\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor\n */\nfunction createFactory(type) {\n\treturn createElement.bind(null, type);\n}\n\n/**\n * Check if the passed element is a valid (p)react node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isValidElement(element) {\n\treturn !!element && element.$$typeof === REACT_ELEMENT_TYPE;\n}\n\n/**\n * Check if the passed element is a Fragment node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isFragment(element) {\n\treturn isValidElement(element) && element.type === Fragment;\n}\n\n/**\n * Check if the passed element is a Memo node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isMemo(element) {\n\treturn (\n\t\t!!element &&\n\t\t!!element.displayName &&\n\t\t(typeof element.displayName === 'string' ||\n\t\t\telement.displayName instanceof String) &&\n\t\telement.displayName.startsWith('Memo(')\n\t);\n}\n\n/**\n * Wrap `cloneElement` to abort if the passed element is not a valid element and apply\n * all vnode normalizations.\n * @param {import('./internal').VNode} element The vnode to clone\n * @param {object} props Props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Optional component children\n */\nfunction cloneElement(element) {\n\tif (!isValidElement(element)) return element;\n\treturn preactCloneElement.apply(null, arguments);\n}\n\n/**\n * Remove a component tree from the DOM, including state and event handlers.\n * @param {import('./internal').PreactElement} container\n * @returns {boolean}\n */\nfunction unmountComponentAtNode(container) {\n\tif (container._children) {\n\t\tpreactRender(null, container);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Get the matching DOM node for a component\n * @param {import('./internal').Component} component\n * @returns {import('./internal').PreactElement | null}\n */\nfunction findDOMNode(component) {\n\treturn (\n\t\t(component &&\n\t\t\t(component.base || (component.nodeType === 1 && component))) ||\n\t\tnull\n\t);\n}\n\n/**\n * Deprecated way to control batched rendering inside the reconciler, but we\n * already schedule in batches inside our rendering code\n * @template Arg\n * @param {(arg: Arg) => void} callback function that triggers the updated\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n */\n// eslint-disable-next-line camelcase\nconst unstable_batchedUpdates = (callback, arg) => callback(arg);\n\n/**\n * In React, `flushSync` flushes the entire tree and forces a rerender. It's\n * implmented here as a no-op.\n * @template Arg\n * @template Result\n * @param {(arg: Arg) => Result} callback function that runs before the flush\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n * @returns\n */\nconst flushSync = (callback, arg) => callback(arg);\n\n/**\n * Strict Mode is not implemented in Preact, so we provide a stand-in for it\n * that just renders its children without imposing any restrictions.\n */\nconst StrictMode = Fragment;\n\n// compat to react-is\nexport const isElement = isValidElement;\n\nexport * from 'preact/hooks';\nexport {\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tisFragment,\n\tisMemo,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tflushSync,\n\tuseInsertionEffect,\n\tstartTransition,\n\tuseDeferredValue,\n\tuseSyncExternalStore,\n\tuseTransition,\n\t// eslint-disable-next-line camelcase\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n\n// React copies the named exports to the default one.\nexport default {\n\tuseState,\n\tuseId,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseInsertionEffect,\n\tuseTransition,\n\tuseDeferredValue,\n\tuseSyncExternalStore,\n\tstartTransition,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tisElement,\n\tisFragment,\n\tisMemo,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tflushSync,\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n",null,"import { EMPTY_ARR } from './constants';\n\nexport const isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-expect-error We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {import('./index').ContainerNode} node The node to remove\n */\nexport function removeNode(node) {\n\tif (node && node.parentNode) node.parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import { slice } from './util';\nimport options from './options';\nimport { NULL, UNDEFINED } from './constants';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != NULL) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === UNDEFINED) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, NULL);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\t/** @type {import('./internal').VNode} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: NULL,\n\t\t_parent: NULL,\n\t\t_depth: 0,\n\t\t_dom: NULL,\n\t\t_component: NULL,\n\t\tconstructor: UNDEFINED,\n\t\t_original: original == NULL ? ++vnodeId : original,\n\t\t_index: -1,\n\t\t_flags: 0\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == NULL && options.vnode != NULL) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: NULL };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != NULL && vnode.constructor == UNDEFINED;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\nimport { MODE_HYDRATE, NULL } from './constants';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function BaseComponent(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != NULL && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == NULL) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](https://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == NULL) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._index + 1)\n\t\t\t: NULL;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != NULL && sibling._dom != NULL) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : NULL;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet oldVNode = component._vnode,\n\t\toldDom = oldVNode._dom,\n\t\tcommitQueue = [],\n\t\trefQueue = [];\n\n\tif (component._parentDom) {\n\t\tconst newVNode = assign({}, oldVNode);\n\t\tnewVNode._original = oldVNode._original + 1;\n\t\tif (options.vnode) options.vnode(newVNode);\n\n\t\tdiff(\n\t\t\tcomponent._parentDom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tcomponent._parentDom.namespaceURI,\n\t\t\toldVNode._flags & MODE_HYDRATE ? [oldDom] : NULL,\n\t\t\tcommitQueue,\n\t\t\toldDom == NULL ? getDomSibling(oldVNode) : oldDom,\n\t\t\t!!(oldVNode._flags & MODE_HYDRATE),\n\t\t\trefQueue\n\t\t);\n\n\t\tnewVNode._original = oldVNode._original;\n\t\tnewVNode._parent._children[newVNode._index] = newVNode;\n\t\tcommitRoot(commitQueue, newVNode, refQueue);\n\n\t\tif (newVNode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(newVNode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != NULL && vnode._component != NULL) {\n\t\tvnode._dom = vnode._component.base = NULL;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != NULL && child._dom != NULL) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {import('./internal').Component} a\n * @param {import('./internal').Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c,\n\t\tl = 1;\n\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile (rerenderQueue.length) {\n\t\t// Keep the rerender queue sorted by (depth, insertion order). The queue\n\t\t// will initially be sorted on the first iteration only if it has more than 1 item.\n\t\t//\n\t\t// New items can be added to the queue e.g. when rerendering a provider, so we want to\n\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t// single pass\n\t\tif (rerenderQueue.length > l) {\n\t\t\trerenderQueue.sort(depthSort);\n\t\t}\n\n\t\tc = rerenderQueue.shift();\n\t\tl = rerenderQueue.length;\n\n\t\tif (c._dirty) {\n\t\t\trenderComponent(c);\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n","import { IS_NON_DIMENSIONAL, NULL, SVG_NAMESPACE } from '../constants';\nimport options from '../options';\n\nfunction setStyle(style, key, value) {\n\tif (key[0] == '-') {\n\t\tstyle.setProperty(key, value == NULL ? '' : value);\n\t} else if (value == NULL) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\nconst CAPTURE_REGEX = /(PointerCapture)$|Capture$/i;\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nlet eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {string} namespace Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, namespace) {\n\tlet useCapture;\n\n\to: if (name == 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] == 'o' && name[1] == 'n') {\n\t\tuseCapture = name != (name = name.replace(CAPTURE_REGEX, '$1'));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (\n\t\t\tname.toLowerCase() in dom ||\n\t\t\tname == 'onFocusOut' ||\n\t\t\tname == 'onFocusIn'\n\t\t)\n\t\t\tname = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tvalue._attached = eventClock;\n\t\t\t\tdom.addEventListener(\n\t\t\t\t\tname,\n\t\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\t\tuseCapture\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvalue._attached = oldValue._attached;\n\t\t\t}\n\t\t} else {\n\t\t\tdom.removeEventListener(\n\t\t\t\tname,\n\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\tuseCapture\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (namespace == SVG_NAMESPACE) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname != 'width' &&\n\t\t\tname != 'height' &&\n\t\t\tname != 'href' &&\n\t\t\tname != 'list' &&\n\t\t\tname != 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname != 'tabIndex' &&\n\t\t\tname != 'download' &&\n\t\t\tname != 'rowSpan' &&\n\t\t\tname != 'colSpan' &&\n\t\t\tname != 'role' &&\n\t\t\tname != 'popover' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == NULL ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\n\t\tif (typeof value == 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != NULL && (value !== false || name[4] == '-')) {\n\t\t\tdom.setAttribute(name, name == 'popover' && value == true ? '' : value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n\t/**\n\t * Proxy an event to hooked event handlers\n\t * @param {import('../internal').PreactEvent} e The event object from the browser\n\t * @private\n\t */\n\treturn function (e) {\n\t\tif (this._listeners) {\n\t\t\tconst eventHandler = this._listeners[e.type + useCapture];\n\t\t\tif (e._dispatched == NULL) {\n\t\t\t\te._dispatched = eventClock++;\n\n\t\t\t\t// When `e._dispatched` is smaller than the time when the targeted event\n\t\t\t\t// handler was attached we know we have bubbled up to an element that was added\n\t\t\t\t// during patching the DOM.\n\t\t\t} else if (e._dispatched < eventHandler._attached) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn eventHandler(options.event ? options.event(e) : e);\n\t\t}\n\t};\n}\n\nconst eventProxy = createEventProxy(false);\nconst eventProxyCapture = createEventProxy(true);\n","import { enqueueRender } from './component';\nimport { NULL } from './constants';\n\nexport let i = 0;\n\nexport function createContext(defaultValue) {\n\tfunction Context(props) {\n\t\tif (!this.getChildContext) {\n\t\t\t/** @type {Set<import('./internal').Component> | null} */\n\t\t\tlet subs = new Set();\n\t\t\tlet ctx = {};\n\t\t\tctx[Context._id] = this;\n\n\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\tsubs = NULL;\n\t\t\t};\n\n\t\t\tthis.shouldComponentUpdate = function (_props) {\n\t\t\t\t// @ts-expect-error even\n\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\tsubs.forEach(c => {\n\t\t\t\t\t\tc._force = true;\n\t\t\t\t\t\tenqueueRender(c);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.sub = c => {\n\t\t\t\tsubs.add(c);\n\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\tif (subs) {\n\t\t\t\t\t\tsubs.delete(c);\n\t\t\t\t\t}\n\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\treturn props.children;\n\t}\n\n\tContext._id = '__cC' + i++;\n\tContext._defaultValue = defaultValue;\n\n\t/** @type {import('./internal').FunctionComponent} */\n\tContext.Consumer = (props, contextValue) => {\n\t\treturn props.children(contextValue);\n\t};\n\n\t// we could also get rid of _contextRef entirely\n\tContext.Provider =\n\t\tContext._contextRef =\n\t\tContext.Consumer.contextType =\n\t\t\tContext;\n\n\treturn Context;\n}\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport {\n\tEMPTY_OBJ,\n\tEMPTY_ARR,\n\tINSERT_VNODE,\n\tMATCHED,\n\tUNDEFINED,\n\tNULL\n} from '../constants';\nimport { isArray } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * @typedef {import('../internal').ComponentChildren} ComponentChildren\n * @typedef {import('../internal').Component} Component\n * @typedef {import('../internal').PreactElement} PreactElement\n * @typedef {import('../internal').VNode} VNode\n */\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\tlet i,\n\t\t/** @type {VNode} */\n\t\toldVNode,\n\t\t/** @type {VNode} */\n\t\tchildVNode,\n\t\t/** @type {PreactElement} */\n\t\tnewDom,\n\t\t/** @type {PreactElement} */\n\t\tfirstChildDom;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\t/** @type {VNode[]} */\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet newChildrenLength = renderResult.length;\n\n\toldDom = constructNewChildrenArray(\n\t\tnewParentVNode,\n\t\trenderResult,\n\t\toldChildren,\n\t\toldDom,\n\t\tnewChildrenLength\n\t);\n\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\tchildVNode = newParentVNode._children[i];\n\t\tif (childVNode == NULL) continue;\n\n\t\t// At this point, constructNewChildrenArray has assigned _index to be the\n\t\t// matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n\t\tif (childVNode._index === -1) {\n\t\t\toldVNode = EMPTY_OBJ;\n\t\t} else {\n\t\t\toldVNode = oldChildren[childVNode._index] || EMPTY_OBJ;\n\t\t}\n\n\t\t// Update childVNode._index to its final index\n\t\tchildVNode._index = i;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tlet result = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\n\t\t// Adjust DOM nodes\n\t\tnewDom = childVNode._dom;\n\t\tif (childVNode.ref && oldVNode.ref != childVNode.ref) {\n\t\t\tif (oldVNode.ref) {\n\t\t\t\tapplyRef(oldVNode.ref, NULL, childVNode);\n\t\t\t}\n\t\t\trefQueue.push(\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildVNode._component || newDom,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t}\n\n\t\tif (firstChildDom == NULL && newDom != NULL) {\n\t\t\tfirstChildDom = newDom;\n\t\t}\n\n\t\tif (\n\t\t\tchildVNode._flags & INSERT_VNODE ||\n\t\t\toldVNode._children === childVNode._children\n\t\t) {\n\t\t\toldDom = insert(childVNode, oldDom, parentDom);\n\t\t} else if (typeof childVNode.type == 'function' && result !== UNDEFINED) {\n\t\t\toldDom = result;\n\t\t} else if (newDom) {\n\t\t\toldDom = newDom.nextSibling;\n\t\t}\n\n\t\t// Unset diffing flags\n\t\tchildVNode._flags &= ~(INSERT_VNODE | MATCHED);\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\treturn oldDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(\n\tnewParentVNode,\n\trenderResult,\n\toldChildren,\n\toldDom,\n\tnewChildrenLength\n) {\n\t/** @type {number} */\n\tlet i;\n\t/** @type {VNode} */\n\tlet childVNode;\n\t/** @type {VNode} */\n\tlet oldVNode;\n\n\tlet oldChildrenLength = oldChildren.length,\n\t\tremainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\n\tnewParentVNode._children = new Array(newChildrenLength);\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\t// @ts-expect-error We are reusing the childVNode variable to hold both the\n\t\t// pre and post normalized childVNode\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == NULL ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tnewParentVNode._children[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint' ||\n\t\t\tchildVNode.constructor == String\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tNULL,\n\t\t\t\tchildVNode,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\t\t} else if (isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\t\t} else if (childVNode.constructor === UNDEFINED && childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : NULL,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\tconst skewedIndex = i + skew;\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Temporarily store the matchingIndex on the _index property so we can pull\n\t\t// out the oldVNode in diffChildren. We'll override this to the VNode's\n\t\t// final index after using this property to get the oldVNode\n\t\tconst matchingIndex = (childVNode._index = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t));\n\n\t\toldVNode = NULL;\n\t\tif (matchingIndex !== -1) {\n\t\t\toldVNode = oldChildren[matchingIndex];\n\t\t\tremainingOldChildren--;\n\t\t\tif (oldVNode) {\n\t\t\t\toldVNode._flags |= MATCHED;\n\t\t\t}\n\t\t}\n\n\t\t// Here, we define isMounting for the purposes of the skew diffing\n\t\t// algorithm. Nodes that are unsuspending are considered mounting and we detect\n\t\t// this by checking if oldVNode._original === null\n\t\tconst isMounting = oldVNode == NULL || oldVNode._original === NULL;\n\n\t\tif (isMounting) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\t// When the array of children is growing we need to decrease the skew\n\t\t\t\t// as we are adding a new element to the array.\n\t\t\t\t// Example:\n\t\t\t\t// [1, 2, 3] --> [0, 1, 2, 3]\n\t\t\t\t// oldChildren   newChildren\n\t\t\t\t//\n\t\t\t\t// The new element is at index 0, so our skew is 0,\n\t\t\t\t// we need to decrease the skew as we are adding a new element.\n\t\t\t\t// The decrease will cause us to compare the element at position 1\n\t\t\t\t// with value 1 with the element at position 0 with value 0.\n\t\t\t\t//\n\t\t\t\t// A linear concept is applied when the array is shrinking,\n\t\t\t\t// if the length is unchanged we can assume that no skew\n\t\t\t\t// changes are needed.\n\t\t\t\tif (newChildrenLength > oldChildrenLength) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else if (newChildrenLength < oldChildrenLength) {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we are mounting a DOM VNode, mark it for insertion\n\t\t\tif (typeof childVNode.type != 'function') {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t} else if (matchingIndex != skewedIndex) {\n\t\t\t// When we move elements around i.e. [0, 1, 2] --> [1, 0, 2]\n\t\t\t// --> we diff 1, we find it at position 1 while our skewed index is 0 and our skew is 0\n\t\t\t//     we set the skew to 1 as we found an offset.\n\t\t\t// --> we diff 0, we find it at position 0 while our skewed index is at 2 and our skew is 1\n\t\t\t//     this makes us increase the skew again.\n\t\t\t// --> we diff 2, we find it at position 2 while our skewed index is at 4 and our skew is 2\n\t\t\t//\n\t\t\t// this becomes an optimization question where currently we see a 1 element offset as an insertion\n\t\t\t// or deletion i.e. we optimize for [0, 1, 2] --> [9, 0, 1, 2]\n\t\t\t// while a more than 1 offset we see as a swap.\n\t\t\t// We could probably build heuristics for having an optimized course of action here as well, but\n\t\t\t// might go at the cost of some bytes.\n\t\t\t//\n\t\t\t// If we wanted to optimize for i.e. only swaps we'd just do the last two code-branches and have\n\t\t\t// only the first item be a re-scouting and all the others fall in their skewed counter-part.\n\t\t\t// We could also further optimize for swaps\n\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\tskew--;\n\t\t\t} else if (matchingIndex == skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t} else {\n\t\t\t\tif (matchingIndex > skewedIndex) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\n\t\t\t\t// Move this VNode's DOM if the original index (matchingIndex) doesn't\n\t\t\t\t// match the new skew index (i + new skew)\n\t\t\t\t// In the former two branches we know that it matches after skewing\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any. Loop forwards so that as we\n\t// unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n\t// point to the next child, which needs to be the first DOM node that won't be\n\t// unmounted.\n\tif (remainingOldChildren) {\n\t\tfor (i = 0; i < oldChildrenLength; i++) {\n\t\t\toldVNode = oldChildren[i];\n\t\t\tif (oldVNode != NULL && (oldVNode._flags & MATCHED) == 0) {\n\t\t\t\tif (oldVNode._dom == oldDom) {\n\t\t\t\t\toldDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn oldDom;\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\n\tif (typeof parentVNode.type == 'function') {\n\t\tlet children = parentVNode._children;\n\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\tif (children[i]) {\n\t\t\t\t// If we enter this code path on sCU bailout, where we copy\n\t\t\t\t// oldVNode._children to newVNode._children, we need to update the old\n\t\t\t\t// children's _parent pointer to point to the newVNode (parentVNode\n\t\t\t\t// here).\n\t\t\t\tchildren[i]._parent = parentVNode;\n\t\t\t\toldDom = insert(children[i], oldDom, parentDom);\n\t\t\t}\n\t\t}\n\n\t\treturn oldDom;\n\t} else if (parentVNode._dom != oldDom) {\n\t\tif (oldDom && parentVNode.type && !parentDom.contains(oldDom)) {\n\t\t\toldDom = getDomSibling(parentVNode);\n\t\t}\n\t\tparentDom.insertBefore(parentVNode._dom, oldDom || NULL);\n\t\toldDom = parentVNode._dom;\n\t}\n\n\tdo {\n\t\toldDom = oldDom && oldDom.nextSibling;\n\t} while (oldDom != NULL && oldDom.nodeType == 8);\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == NULL || typeof children == 'boolean') {\n\t} else if (isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst key = childVNode.key;\n\tconst type = childVNode.type;\n\tlet oldVNode = oldChildren[skewedIndex];\n\n\t// We only need to perform a search if there are more children\n\t// (remainingOldChildren) to search. However, if the oldVNode we just looked\n\t// at skewedIndex was not already used in this diff, then there must be at\n\t// least 1 other (so greater than 1) remainingOldChildren to attempt to match\n\t// against. So the following condition checks that ensuring\n\t// remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n\t// if the oldVNode was null or matched, then there could needs to be at least\n\t// 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n\t//\n\t// If there is an unkeyed functional VNode, that isn't a built-in like our Fragment,\n\t// we should not search as we risk re-using state of an unrelated VNode. (reverted for now)\n\tlet shouldSearch =\n\t\t// (typeof type != 'function' || type === Fragment || key) &&\n\t\tremainingOldChildren >\n\t\t(oldVNode != NULL && (oldVNode._flags & MATCHED) == 0 ? 1 : 0);\n\n\tif (\n\t\t(oldVNode === NULL && childVNode.key == null) ||\n\t\t(oldVNode &&\n\t\t\tkey == oldVNode.key &&\n\t\t\ttype === oldVNode.type &&\n\t\t\t(oldVNode._flags & MATCHED) == 0)\n\t) {\n\t\treturn skewedIndex;\n\t} else if (shouldSearch) {\n\t\tlet x = skewedIndex - 1;\n\t\tlet y = skewedIndex + 1;\n\t\twhile (x >= 0 || y < oldChildren.length) {\n\t\t\tif (x >= 0) {\n\t\t\t\toldVNode = oldChildren[x];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) == 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\tx--;\n\t\t\t}\n\n\t\t\tif (y < oldChildren.length) {\n\t\t\t\toldVNode = oldChildren[y];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) == 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn y;\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n","import {\n\tEMPTY_OBJ,\n\tMATH_NAMESPACE,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tNULL,\n\tRESET_MODE,\n\tSVG_NAMESPACE,\n\tUNDEFINED,\n\tXHTML_NAMESPACE\n} from '../constants';\nimport { BaseComponent, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { setProperty } from './props';\nimport { assign, isArray, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * @typedef {import('../internal').ComponentChildren} ComponentChildren\n * @typedef {import('../internal').Component} Component\n * @typedef {import('../internal').PreactElement} PreactElement\n * @typedef {import('../internal').VNode} VNode\n */\n\n/**\n * @template {any} T\n * @typedef {import('../internal').Ref<T>} Ref<T>\n */\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\t/** @type {any} */\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== UNDEFINED) return NULL;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._flags & MODE_SUSPENDED) {\n\t\tisHydrating = !!(oldVNode._flags & MODE_HYDRATE);\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\touter: if (typeof newType == 'function') {\n\t\ttry {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\t\t\tconst isClassComponent =\n\t\t\t\t'prototype' in newType && newType.prototype.render;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif (isClassComponent) {\n\t\t\t\t\t// @ts-expect-error The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new BaseComponent(\n\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (isClassComponent && c._nextState == NULL) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (isClassComponent && newType.getDerivedStateFromProps != NULL) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == NULL &&\n\t\t\t\t\tc.componentWillMount != NULL\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidMount != NULL) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == NULL &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != NULL\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!c._force &&\n\t\t\t\t\t((c.shouldComponentUpdate != NULL &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\t\tnewVNode._original == oldVNode._original)\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original != oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.some(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != NULL) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidUpdate != NULL) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\t\t\tc._force = false;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif (isClassComponent) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != NULL) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (isClassComponent && !isNew && c.getSnapshotBeforeUpdate != NULL) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != NULL && tmp.type === Fragment && tmp.key == NULL;\n\t\t\tlet renderResult = tmp;\n\n\t\t\tif (isTopLevelFragment) {\n\t\t\t\trenderResult = cloneNode(tmp.props.children);\n\t\t\t}\n\n\t\t\toldDom = diffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tisArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnamespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._flags &= RESET_MODE;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = NULL;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnewVNode._original = NULL;\n\t\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\t\tif (isHydrating || excessDomChildren != NULL) {\n\t\t\t\tif (e.then) {\n\t\t\t\t\tnewVNode._flags |= isHydrating\n\t\t\t\t\t\t? MODE_HYDRATE | MODE_SUSPENDED\n\t\t\t\t\t\t: MODE_SUSPENDED;\n\n\t\t\t\t\twhile (oldDom && oldDom.nodeType == 8 && oldDom.nextSibling) {\n\t\t\t\t\t\toldDom = oldDom.nextSibling;\n\t\t\t\t\t}\n\n\t\t\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = NULL;\n\t\t\t\t\tnewVNode._dom = oldDom;\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = excessDomChildren.length; i--; ) {\n\t\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t}\n\t\t\toptions._catchError(e, newVNode, oldVNode);\n\t\t}\n\t} else if (\n\t\texcessDomChildren == NULL &&\n\t\tnewVNode._original == oldVNode._original\n\t) {\n\t\tnewVNode._children = oldVNode._children;\n\t\tnewVNode._dom = oldVNode._dom;\n\t} else {\n\t\toldDom = newVNode._dom = diffElementNodes(\n\t\t\toldVNode._dom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\t}\n\n\tif ((tmp = options.diffed)) tmp(newVNode);\n\n\treturn newVNode._flags & MODE_SUSPENDED ? undefined : oldDom;\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nexport function commitRoot(commitQueue, root, refQueue) {\n\tfor (let i = 0; i < refQueue.length; i++) {\n\t\tapplyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n\t}\n\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-expect-error Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-expect-error See above comment on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\nfunction cloneNode(node) {\n\tif (typeof node !== 'object' || node == NULL) {\n\t\treturn node;\n\t}\n\n\tif (isArray(node)) {\n\t\treturn node.map(cloneNode);\n\t}\n\n\treturn assign({}, node);\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating,\n\trefQueue\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = /** @type {string} */ (newVNode.type);\n\t/** @type {any} */\n\tlet i;\n\t/** @type {{ __html?: string }} */\n\tlet newHtml;\n\t/** @type {{ __html?: string }} */\n\tlet oldHtml;\n\t/** @type {ComponentChildren} */\n\tlet newChildren;\n\tlet value;\n\tlet inputValue;\n\tlet checked;\n\n\t// Tracks entering and exiting namespaces when descending through the tree.\n\tif (nodeType == 'svg') namespace = SVG_NAMESPACE;\n\telse if (nodeType == 'math') namespace = MATH_NAMESPACE;\n\telse if (!namespace) namespace = XHTML_NAMESPACE;\n\n\tif (excessDomChildren != NULL) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tvalue = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tvalue &&\n\t\t\t\t'setAttribute' in value == !!nodeType &&\n\t\t\t\t(nodeType ? value.localName == nodeType : value.nodeType == 3)\n\t\t\t) {\n\t\t\t\tdom = value;\n\t\t\t\texcessDomChildren[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == NULL) {\n\t\tif (nodeType == NULL) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = document.createElementNS(\n\t\t\tnamespace,\n\t\t\tnodeType,\n\t\t\tnewProps.is && newProps\n\t\t);\n\n\t\t// we are creating a new node, so we can assume this is a new subtree (in\n\t\t// case we are hydrating), this deopts the hydrate\n\t\tif (isHydrating) {\n\t\t\tif (options._hydrationMismatch)\n\t\t\t\toptions._hydrationMismatch(newVNode, excessDomChildren);\n\t\t\tisHydrating = false;\n\t\t}\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = NULL;\n\t}\n\n\tif (nodeType === NULL) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\t// If we are in a situation where we are not hydrating but are using\n\t\t// existing DOM (e.g. replaceNode) we should read the existing DOM\n\t\t// attributes to diff them\n\t\tif (!isHydrating && excessDomChildren != NULL) {\n\t\t\toldProps = {};\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i];\n\t\t\t\toldProps[value.name] = value.value;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in oldProps) {\n\t\t\tvalue = oldProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\toldHtml = value;\n\t\t\t} else if (!(i in newProps)) {\n\t\t\t\tif (\n\t\t\t\t\t(i == 'value' && 'defaultValue' in newProps) ||\n\t\t\t\t\t(i == 'checked' && 'defaultChecked' in newProps)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetProperty(dom, i, NULL, value, namespace);\n\t\t\t}\n\t\t}\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i == 'value') {\n\t\t\t\tinputValue = value;\n\t\t\t} else if (i == 'checked') {\n\t\t\t\tchecked = value;\n\t\t\t} else if (\n\t\t\t\t(!isHydrating || typeof value == 'function') &&\n\t\t\t\toldProps[i] !== value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\tif (\n\t\t\t\t!isHydrating &&\n\t\t\t\t(!oldHtml ||\n\t\t\t\t\t(newHtml.__html !== oldHtml.__html &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML))\n\t\t\t) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\t\tdiffChildren(\n\t\t\t\t// @ts-expect-error\n\t\t\t\tnewVNode.type === 'template' ? dom.content : dom,\n\t\t\t\tisArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnodeType == 'foreignObject' ? XHTML_NAMESPACE : namespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != NULL) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// As above, don't diff props during hydration\n\t\tif (!isHydrating) {\n\t\t\ti = 'value';\n\t\t\tif (nodeType == 'progress' && inputValue == NULL) {\n\t\t\t\tdom.removeAttribute('value');\n\t\t\t} else if (\n\t\t\t\tinputValue !== UNDEFINED &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(inputValue !== dom[i] ||\n\t\t\t\t\t(nodeType == 'progress' && !inputValue) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType == 'option' && inputValue !== oldProps[i]))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, inputValue, oldProps[i], namespace);\n\t\t\t}\n\n\t\t\ti = 'checked';\n\t\t\tif (checked !== UNDEFINED && checked !== dom[i]) {\n\t\t\t\tsetProperty(dom, i, checked, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any> & { _unmount?: unknown }} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') {\n\t\t\tlet hasRefUnmount = typeof ref._unmount == 'function';\n\t\t\tif (hasRefUnmount) {\n\t\t\t\t// @ts-ignore TS doesn't like moving narrowing checks into variables\n\t\t\t\tref._unmount();\n\t\t\t}\n\n\t\t\tif (!hasRefUnmount || value != NULL) {\n\t\t\t\t// Store the cleanup function on the function\n\t\t\t\t// instance object itself to avoid shape\n\t\t\t\t// transitioning vnode\n\t\t\t\tref._unmount = ref(value);\n\t\t\t}\n\t\t} else ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) {\n\t\t\tapplyRef(r, NULL, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != NULL) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = NULL;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type != 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\tvnode._component = vnode._parent = vnode._dom = UNDEFINED;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { EMPTY_OBJ, NULL } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to render into\n * @param {import('./internal').PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\t// https://github.com/preactjs/preact/issues/3794\n\tif (parentDom == document) {\n\t\tparentDom = document.documentElement;\n\t}\n\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode == 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? NULL\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = ((!isHydrating && replaceNode) || parentDom)._children =\n\t\tcreateElement(Fragment, NULL, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [],\n\t\trefQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.namespaceURI,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t\t? NULL\n\t\t\t\t: parentDom.firstChild\n\t\t\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t\t\t: NULL,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t\t? oldVNode._dom\n\t\t\t\t: parentDom.firstChild,\n\t\tisHydrating,\n\t\trefQueue\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n","import { assign, slice } from './util';\nimport { createVNode } from './create-element';\nimport { NULL, UNDEFINED } from './constants';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tlet defaultProps;\n\n\tif (vnode.type && vnode.type.defaultProps) {\n\t\tdefaultProps = vnode.type.defaultProps;\n\t}\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse if (props[i] === UNDEFINED && defaultProps !== UNDEFINED) {\n\t\t\tnormalizedProps[i] = defaultProps[i];\n\t\t} else {\n\t\t\tnormalizedProps[i] = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tNULL\n\t);\n}\n","import { NULL } from '../constants';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {import('../internal').VNode} [oldVNode]\n * @param {import('../internal').ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {import('../internal').Component} */\n\tlet component,\n\t\t/** @type {import('../internal').ComponentType} */\n\t\tctor,\n\t\t/** @type {boolean} */\n\t\thandled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != NULL) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != NULL) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n",null,"import { options as _options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {import('./internal').Component} */\nlet previousComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\n// Cast to use internal Options type\nconst options = /** @type {import('./internal').Options} */ (_options);\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\nlet oldRoot = options._root;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._diff = vnode => {\n\tcurrentComponent = null;\n\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n};\n\noptions._root = (vnode, parentDom) => {\n\tif (vnode && parentDom._children && parentDom._children._mask) {\n\t\tvnode._mask = parentDom._children._mask;\n\t}\n\n\tif (oldRoot) oldRoot(vnode, parentDom);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\tif (previousComponent === currentComponent) {\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentComponent._renderCallbacks = [];\n\t\t\thooks._list.forEach(hookItem => {\n\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t}\n\t\t\t\thookItem._pendingArgs = hookItem._nextValue = undefined;\n\t\t\t});\n\t\t} else {\n\t\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentIndex = 0;\n\t\t}\n\t}\n\tpreviousComponent = currentComponent;\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tif (c.__hooks._pendingEffects.length) afterPaint(afterPaintEffects.push(c));\n\t\tc.__hooks._list.forEach(hookItem => {\n\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t}\n\t\t\thookItem._pendingArgs = undefined;\n\t\t});\n\t}\n\tpreviousComponent = currentComponent = null;\n};\n\n// TODO: Improve typing of commitQueue parameter\n/** @type {(vnode: import('./internal').VNode, commitQueue: any) => void} */\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tlet hasErrored;\n\t\tc.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tc.__hooks = undefined;\n\t\tif (hasErrored) options._catchError(hasErrored, c._vnode);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\n\treturn hooks._list[index];\n}\n\n/**\n * @template {unknown} S\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} [initialState]\n * @returns {[S, (state: S) => void]}\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @template {unknown} S\n * @template {unknown} A\n * @param {import('./index').Reducer<S, A>} reducer\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ S, (state: S) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst currentValue = hookState._nextValue\n\t\t\t\t\t? hookState._nextValue[0]\n\t\t\t\t\t: hookState._value[0];\n\t\t\t\tconst nextValue = hookState._reducer(currentValue, action);\n\n\t\t\t\tif (currentValue !== nextValue) {\n\t\t\t\t\thookState._nextValue = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._component = currentComponent;\n\n\t\tif (!currentComponent._hasScuFromHooks) {\n\t\t\tcurrentComponent._hasScuFromHooks = true;\n\t\t\tlet prevScu = currentComponent.shouldComponentUpdate;\n\t\t\tconst prevCWU = currentComponent.componentWillUpdate;\n\n\t\t\t// If we're dealing with a forced update `shouldComponentUpdate` will\n\t\t\t// not be called. But we use that to update the hook values, so we\n\t\t\t// need to call it.\n\t\t\tcurrentComponent.componentWillUpdate = function (p, s, c) {\n\t\t\t\tif (this._force) {\n\t\t\t\t\tlet tmp = prevScu;\n\t\t\t\t\t// Clear to avoid other sCU hooks from being called\n\t\t\t\t\tprevScu = undefined;\n\t\t\t\t\tupdateHookState(p, s, c);\n\t\t\t\t\tprevScu = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (prevCWU) prevCWU.call(this, p, s, c);\n\t\t\t};\n\n\t\t\t// This SCU has the purpose of bailing out after repeated updates\n\t\t\t// to stateful hooks.\n\t\t\t// we store the next value in _nextValue[0] and keep doing that for all\n\t\t\t// state setters, if we have next states and\n\t\t\t// all next states within a component end up being equal to their original state\n\t\t\t// we are safe to bail out for this specific component.\n\t\t\t/**\n\t\t\t *\n\t\t\t * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n\t\t\t */\n\t\t\t// @ts-ignore - We don't use TS to downtranspile\n\t\t\t// eslint-disable-next-line no-inner-declarations\n\t\t\tfunction updateHookState(p, s, c) {\n\t\t\t\tif (!hookState._component.__hooks) return true;\n\n\t\t\t\t/** @type {(x: import('./internal').HookState) => x is import('./internal').ReducerHookState} */\n\t\t\t\tconst isStateHook = x => !!x._component;\n\t\t\t\tconst stateHooks =\n\t\t\t\t\thookState._component.__hooks._list.filter(isStateHook);\n\n\t\t\t\tconst allHooksEmpty = stateHooks.every(x => !x._nextValue);\n\t\t\t\t// When we have no updated hooks in the component we invoke the previous SCU or\n\t\t\t\t// traverse the VDOM tree further.\n\t\t\t\tif (allHooksEmpty) {\n\t\t\t\t\treturn prevScu ? prevScu.call(this, p, s, c) : true;\n\t\t\t\t}\n\n\t\t\t\t// We check whether we have components with a nextValue set that\n\t\t\t\t// have values that aren't equal to one another this pushes\n\t\t\t\t// us to update further down the tree\n\t\t\t\tlet shouldUpdate = hookState._component.props !== p;\n\t\t\t\tstateHooks.forEach(hookItem => {\n\t\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\t\tconst currentValue = hookItem._value[0];\n\t\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t\t\thookItem._nextValue = undefined;\n\t\t\t\t\t\tif (currentValue !== hookItem._value[0]) shouldUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn prevScu\n\t\t\t\t\t? prevScu.call(this, p, s, c) || shouldUpdate\n\t\t\t\t\t: shouldUpdate;\n\t\t\t}\n\n\t\t\tcurrentComponent.shouldComponentUpdate = updateHookState;\n\t\t}\n\t}\n\n\treturn hookState._nextValue || hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\n/** @type {(initialValue: unknown) => unknown} */\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') {\n\t\t\t\tconst result = ref(createHandle());\n\t\t\t\treturn () => {\n\t\t\t\t\tref(null);\n\t\t\t\t\tif (result && typeof result == 'function') result();\n\t\t\t\t};\n\t\t\t} else if (ref) {\n\t\t\t\tref.current = createHandle();\n\t\t\t\treturn () => (ref.current = null);\n\t\t\t}\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @template {unknown} T\n * @param {() => T} factory\n * @param {unknown[]} args\n * @returns {T}\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState<T>} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._value = factory();\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {unknown[]} args\n * @returns {() => void}\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(\n\t\t\tformatter ? formatter(value) : /** @type {any}*/ (value)\n\t\t);\n\t}\n}\n\n/**\n * @param {(error: unknown, errorInfo: import('preact').ErrorInfo) => void} cb\n * @returns {[unknown, () => void]}\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = (err, errorInfo) => {\n\t\t\tif (state._value) state._value(err, errorInfo);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/** @type {() => string} */\nexport function useId() {\n\t/** @type {import('./internal').IdHookState} */\n\tconst state = getHookState(currentIndex++, 11);\n\tif (!state._value) {\n\t\t// Grab either the root node or the nearest async boundary node.\n\t\t/** @type {import('./internal').VNode} */\n\t\tlet root = currentComponent._vnode;\n\t\twhile (root !== null && !root._mask && root._parent !== null) {\n\t\t\troot = root._parent;\n\t\t}\n\n\t\tlet mask = root._mask || (root._mask = [0, 0]);\n\t\tstate._value = 'P' + mask[0] + '-' + mask[1]++;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet component;\n\twhile ((component = afterPaintEffects.shift())) {\n\t\tif (!component._parentDom || !component.__hooks) continue;\n\t\ttry {\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t} catch (e) {\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n * @returns {void}\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').HookState} hook\n * @returns {void}\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\n\tcurrentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n * @returns {void}\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\thook._cleanup = hook._value();\n\tcurrentComponent = comp;\n}\n\n/**\n * @param {unknown[]} oldArgs\n * @param {unknown[]} newArgs\n * @returns {boolean}\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\n/**\n * @template Arg\n * @param {Arg} arg\n * @param {(arg: Arg) => any} f\n * @returns {any}\n */\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n",null,"const ENCODED_ENTITIES = /[\"&<]/;\n\n/** @param {string} str */\nexport function encodeEntities(str) {\n\t// Skip all work for strings with no entities needing encoding:\n\tif (str.length === 0 || ENCODED_ENTITIES.test(str) === false) return str;\n\n\tlet last = 0,\n\t\ti = 0,\n\t\tout = '',\n\t\tch = '';\n\n\t// Seek forward in str until the next entity char:\n\tfor (; i < str.length; i++) {\n\t\tswitch (str.charCodeAt(i)) {\n\t\t\tcase 34:\n\t\t\t\tch = '&quot;';\n\t\t\t\tbreak;\n\t\t\tcase 38:\n\t\t\t\tch = '&amp;';\n\t\t\t\tbreak;\n\t\t\tcase 60:\n\t\t\t\tch = '&lt;';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t}\n\t\t// Append skipped/buffered characters and the encoded entity:\n\t\tif (i !== last) out += str.slice(last, i);\n\t\tout += ch;\n\t\t// Start the next seek/buffer after the entity's offset:\n\t\tlast = i + 1;\n\t}\n\tif (i !== last) out += str.slice(last, i);\n\treturn out;\n}\n","import { options, Fragment } from 'preact';\nimport { encodeEntities } from './utils';\nimport { IS_NON_DIMENSIONAL } from '../../src/constants';\n\nlet vnodeId = 0;\n\nconst isArray = Array.isArray;\n\n/**\n * @fileoverview\n * This file exports various methods that implement Babel's \"automatic\" JSX runtime API:\n * - jsx(type, props, key)\n * - jsxs(type, props, key)\n * - jsxDEV(type, props, key, __source, __self)\n *\n * The implementation of createVNode here is optimized for performance.\n * Benchmarks: https://esbench.com/bench/5f6b54a0b4632100a7dcd2b3\n */\n\n/**\n * JSX.Element factory used by Babel's {runtime:\"automatic\"} JSX transform\n * @param {VNode['type']} type\n * @param {VNode['props']} props\n * @param {VNode['key']} [key]\n * @param {unknown} [isStaticChildren]\n * @param {unknown} [__source]\n * @param {unknown} [__self]\n */\nfunction createVNode(type, props, key, isStaticChildren, __source, __self) {\n\tif (!props) props = {};\n\t// We'll want to preserve `ref` in props to get rid of the need for\n\t// forwardRef components in the future, but that should happen via\n\t// a separate PR.\n\tlet normalizedProps = props,\n\t\tref,\n\t\ti;\n\n\tif ('ref' in normalizedProps) {\n\t\tnormalizedProps = {};\n\t\tfor (i in props) {\n\t\t\tif (i == 'ref') {\n\t\t\t\tref = props[i];\n\t\t\t} else {\n\t\t\t\tnormalizedProps[i] = props[i];\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @type {VNode & { __source: any; __self: any }} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops: normalizedProps,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: --vnodeId,\n\t\t_index: -1,\n\t\t_flags: 0,\n\t\t__source,\n\t\t__self\n\t};\n\n\t// If a Component VNode, check for and apply defaultProps.\n\t// Note: `type` is often a String, and can be `undefined` in development.\n\tif (typeof type === 'function' && (ref = type.defaultProps)) {\n\t\tfor (i in ref)\n\t\t\tif (typeof normalizedProps[i] === 'undefined') {\n\t\t\t\tnormalizedProps[i] = ref[i];\n\t\t\t}\n\t}\n\n\tif (options.vnode) options.vnode(vnode);\n\treturn vnode;\n}\n\n/**\n * Create a template vnode. This function is not expected to be\n * used directly, but rather through a precompile JSX transform\n * @param {string[]} templates\n * @param  {Array<string | null | VNode>} exprs\n * @returns {VNode}\n */\nfunction jsxTemplate(templates, ...exprs) {\n\tconst vnode = createVNode(Fragment, { tpl: templates, exprs });\n\t// Bypass render to string top level Fragment optimization\n\tvnode.key = vnode._vnode;\n\treturn vnode;\n}\n\nconst JS_TO_CSS = {};\nconst CSS_REGEX = /[A-Z]/g;\n\n/**\n * Serialize an HTML attribute to a string. This function is not\n * expected to be used directly, but rather through a precompile\n * JSX transform\n * @param {string} name The attribute name\n * @param {*} value The attribute value\n * @returns {string}\n */\nfunction jsxAttr(name, value) {\n\tif (options.attr) {\n\t\tconst result = options.attr(name, value);\n\t\tif (typeof result === 'string') return result;\n\t}\n\n\tif (name === 'ref' || name === 'key') return '';\n\tif (name === 'style' && typeof value === 'object') {\n\t\tlet str = '';\n\t\tfor (let prop in value) {\n\t\t\tlet val = value[prop];\n\t\t\tif (val != null && val !== '') {\n\t\t\t\tconst name =\n\t\t\t\t\tprop[0] == '-'\n\t\t\t\t\t\t? prop\n\t\t\t\t\t\t: JS_TO_CSS[prop] ||\n\t\t\t\t\t\t\t(JS_TO_CSS[prop] = prop.replace(CSS_REGEX, '-$&').toLowerCase());\n\n\t\t\t\tlet suffix = ';';\n\t\t\t\tif (\n\t\t\t\t\ttypeof val === 'number' &&\n\t\t\t\t\t// Exclude custom-attributes\n\t\t\t\t\t!name.startsWith('--') &&\n\t\t\t\t\t!IS_NON_DIMENSIONAL.test(name)\n\t\t\t\t) {\n\t\t\t\t\tsuffix = 'px;';\n\t\t\t\t}\n\t\t\t\tstr = str + name + ':' + val + suffix;\n\t\t\t}\n\t\t}\n\t\treturn name + '=\"' + str + '\"';\n\t}\n\n\tif (\n\t\tvalue == null ||\n\t\tvalue === false ||\n\t\ttypeof value === 'function' ||\n\t\ttypeof value === 'object'\n\t) {\n\t\treturn '';\n\t} else if (value === true) return name;\n\n\treturn name + '=\"' + encodeEntities(value) + '\"';\n}\n\n/**\n * Escape a dynamic child passed to `jsxTemplate`. This function\n * is not expected to be used directly, but rather through a\n * precompile JSX transform\n * @param {*} value\n * @returns {string | null | VNode | Array<string | null | VNode>}\n */\nfunction jsxEscape(value) {\n\tif (\n\t\tvalue == null ||\n\t\ttypeof value === 'boolean' ||\n\t\ttypeof value === 'function'\n\t) {\n\t\treturn null;\n\t}\n\n\tif (typeof value === 'object') {\n\t\t// Check for VNode\n\t\tif (value.constructor === undefined) return value;\n\n\t\tif (isArray(value)) {\n\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\tvalue[i] = jsxEscape(value[i]);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n\n\treturn encodeEntities('' + value);\n}\n\nexport {\n\tcreateVNode as jsx,\n\tcreateVNode as jsxs,\n\tcreateVNode as jsxDEV,\n\tFragment,\n\t// precompiled JSX transform\n\tjsxTemplate,\n\tjsxAttr,\n\tjsxEscape\n};\n","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t(require(\"react\")):\"function\"==typeof define&&define.amd?define([\"react\"],t):\"object\"==typeof exports?exports[\"react-timer-hook\"]=t(require(\"react\")):e[\"react-timer-hook\"]=t(e.react)}(\"undefined\"!=typeof self?self:this,(e=>(()=>{\"use strict\";var t={155:t=>{t.exports=e}},s={};function o(e){var r=s[e];if(void 0!==r)return r.exports;var i=s[e]={exports:{}};return t[e](i,i.exports,o),i.exports}o.d=(e,t)=>{for(var s in t)o.o(t,s)&&!o.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},o.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),o.r=e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})};var r={};o.r(r),o.d(r,{default:()=>p,useStopwatch:()=>m,useTime:()=>d,useTimer:()=>u});var i=o(155);class n{static getTimeFromMilliseconds(e){const t=arguments.length>1&&void 0!==arguments[1]&&!arguments[1]?Math.floor(e/1e3):Math.ceil(e/1e3),s=Math.floor(t/86400),o=Math.floor(t%86400/3600),r=Math.floor(t%3600/60),i=Math.floor(t%60);return{totalMilliseconds:e,totalSeconds:t,milliseconds:Math.floor(e%1e3),seconds:i,minutes:r,hours:o,days:s}}static getMillisecondsFromExpiry(e){const t=e-(new Date).getTime();return t>0?t:0}static getMillisecondsFromPrevTime(e){const t=(new Date).getTime()-e;return t>0?t:0}static getMillisecondsFromTimeNow(){const e=new Date;return e.getTime()-60*e.getTimezoneOffset()*1e3}static getFormattedTimeFromMilliseconds(e,t){const{milliseconds:s,seconds:o,minutes:r,hours:i}=n.getTimeFromMilliseconds(e);let l=\"\",a=i;return\"12-hour\"===t&&(l=i>=12?\"pm\":\"am\",a=i%12),{milliseconds:s,seconds:o,minutes:r,hours:a,ampm:l}}}class l{static expiryTimestamp(e){const t=new Date(e).getTime()>0;return t||console.warn(\"react-timer-hook: { useTimer } Invalid expiryTimestamp settings\",e),t}static onExpire(e){const t=e&&\"function\"==typeof e;return e&&!t&&console.warn(\"react-timer-hook: { useTimer } Invalid onExpire settings function\",e),t}}function a(e,t){const s=(0,i.useRef)();(0,i.useEffect)((()=>{s.current=e})),(0,i.useEffect)((()=>{if(!t)return()=>{};const e=setInterval((()=>{s.current&&s.current()}),t);return()=>clearInterval(e)}),[t])}const c=1e3;function u(){let{expiryTimestamp:e,onExpire:t,autoStart:s=!0,interval:o=c}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const[r,u]=(0,i.useState)(e),[m,d]=(0,i.useState)(n.getMillisecondsFromExpiry(r)),[p,f]=(0,i.useState)(s),[g,T]=(0,i.useState)(s),[M,v]=(0,i.useState)(o),y=(0,i.useCallback)((()=>{l.onExpire(t)&&t(),f(!1),v(null)}),[t]),h=(0,i.useCallback)((()=>{f(!1)}),[]),x=(0,i.useCallback)((function(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];v(o),T(t),f(t),u(e),d(n.getMillisecondsFromExpiry(e))}),[o]),F=(0,i.useCallback)((()=>{const e=new Date;e.setMilliseconds(e.getMilliseconds()+m),x(e)}),[m,x]),w=(0,i.useCallback)((()=>{g?(d(n.getMillisecondsFromExpiry(r)),f(!0)):F()}),[r,g,F]);return a((()=>{const e=n.getMillisecondsFromExpiry(r);d(e),e<=0?y():e<M&&v(e)}),p?M:null),(0,i.useEffect)((()=>{l.expiryTimestamp(r)}),[r]),{...n.getTimeFromMilliseconds(m),start:w,pause:h,resume:F,restart:x,isRunning:p}}function m(){let{autoStart:e,offsetTimestamp:t,interval:s=c}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const o=n.getMillisecondsFromExpiry(t)||0,[r,l]=(0,i.useState)(new Date-new Date(o)),[u,m]=(0,i.useState)(n.getMillisecondsFromPrevTime(r||0)),[d,p]=(0,i.useState)(e),f=c-u%c,[g,T]=(0,i.useState)(s<f?s:f);a((()=>{g!==s&&T(s),m(n.getMillisecondsFromPrevTime(r))}),d?g:null);const M=(0,i.useCallback)((()=>{l(new Date-new Date(u)),p(!0)}),[u]),v=(0,i.useCallback)((()=>{m(n.getMillisecondsFromPrevTime(r)),p(!1)}),[r]),y=(0,i.useCallback)((function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const o=n.getMillisecondsFromExpiry(e)||0,r=new Date-new Date(o),i=n.getMillisecondsFromPrevTime(r),a=c-i%c;l(r),m(i),T(s<a?s:a),p(t)}),[s]);return{...n.getTimeFromMilliseconds(u,!1),start:M,pause:v,reset:y,isRunning:d}}function d(){let{format:e,interval:t=c}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const[s,o]=(0,i.useState)(n.getMillisecondsFromTimeNow());return a((()=>{o(n.getMillisecondsFromTimeNow())}),t),{...n.getFormattedTimeFromMilliseconds(s,e)}}function p(e){if((0,i.useEffect)((()=>{console.warn(\"react-timer-hook: default export useTimer is deprecated, use named exports { useTimer, useStopwatch, useTime } instead\")}),[]),e.expiryTimestamp){const t=u(e);return{...t,startTimer:t.start,stopTimer:t.pause,resetTimer:()=>{}}}const t=m(e);return{...t,startTimer:t.start,stopTimer:t.pause,resetTimer:t.reset}}return r})()));","\"use strict\";\n\nvar Refresh = require('react-refresh/runtime');\nvar {\n  version\n} = require('react-refresh/package.json');\nfunction debounce(func, delay) {\n  if (process.env.NODE_ENV === 'test') {\n    return function (args) {\n      func.call(null, args);\n    };\n  } else {\n    let timeout = undefined;\n    let lastTime = 0;\n    return function (args) {\n      // Call immediately if last call was more than the delay ago.\n      // Otherwise, set a timeout. This means the first call is fast\n      // (for the common case of a single update), and subsequent updates\n      // are batched.\n      let now = Date.now();\n      if (now - lastTime > delay) {\n        lastTime = now;\n        func.call(null, args);\n      } else {\n        clearTimeout(timeout);\n        timeout = setTimeout(function () {\n          timeout = undefined;\n          lastTime = Date.now();\n          func.call(null, args);\n        }, delay);\n      }\n    };\n  }\n}\nvar enqueueUpdate = debounce(function () {\n  Refresh.performReactRefresh();\n}, 30);\n\n// Everything below is either adapted or copied from\n// https://github.com/facebook/metro/blob/61de16bd1edd7e738dd0311c89555a644023ab2d/packages/metro/src/lib/polyfills/require.js\n// MIT License - Copyright (c) Facebook, Inc. and its affiliates.\n\nmodule.exports.prelude = function (module) {\n  window.__REACT_REFRESH_VERSION_TRANSFORMER = version;\n  window.$RefreshReg$ = function (type, id) {\n    if (window.__REACT_REFRESH_VERSION_TRANSFORMER && window.__REACT_REFRESH_VERSION_RUNTIME && window.__REACT_REFRESH_VERSION_TRANSFORMER !== window.__REACT_REFRESH_VERSION_RUNTIME) {\n      // Both versions were set and they did not match\n      throw new Error(`react-refresh versions did not match between transformer and runtime. Please check your dependencies. Transformer: ${window.__REACT_REFRESH_VERSION_TRANSFORMER}, Runtime: ${window.__REACT_REFRESH_VERSION_RUNTIME}`);\n    }\n    Refresh.register(type, module.id + ' ' + id);\n  };\n  window.$RefreshSig$ = Refresh.createSignatureFunctionForTransform;\n};\nmodule.exports.postlude = function (module) {\n  if (isReactRefreshBoundary(module.exports)) {\n    registerExportsForReactRefresh(module);\n    if (module.hot) {\n      module.hot.dispose(function (data) {\n        if (Refresh.hasUnrecoverableErrors()) {\n          window.location.reload();\n        }\n        data.prevExports = module.exports;\n      });\n      module.hot.accept(function (getParents) {\n        var prevExports = module.hot.data.prevExports;\n        var nextExports = module.exports;\n        // Since we just executed the code for it, it's possible\n        // that the new exports make it ineligible for being a boundary.\n        var isNoLongerABoundary = !isReactRefreshBoundary(nextExports);\n        // It can also become ineligible if its exports are incompatible\n        // with the previous exports.\n        // For example, if you add/remove/change exports, we'll want\n        // to re-execute the importing modules, and force those components\n        // to re-render. Similarly, if you convert a class component\n        // to a function, we want to invalidate the boundary.\n        var didInvalidate = shouldInvalidateReactRefreshBoundary(prevExports, nextExports);\n        if (isNoLongerABoundary || didInvalidate) {\n          // We'll be conservative. The only case in which we won't do a full\n          // reload is if all parent modules are also refresh boundaries.\n          // In that case we'll add them to the current queue.\n          var parents = getParents();\n          if (parents.length === 0) {\n            // Looks like we bubbled to the root. Can't recover from that.\n            window.location.reload();\n            return;\n          }\n          return parents;\n        }\n        enqueueUpdate();\n      });\n    }\n  }\n};\nfunction isReactRefreshBoundary(exports) {\n  if (Refresh.isLikelyComponentType(exports)) {\n    return true;\n  }\n  if (exports == null || typeof exports !== 'object') {\n    // Exit if we can't iterate over exports.\n    return false;\n  }\n  var hasExports = false;\n  var areAllExportsComponents = true;\n  let isESM = '__esModule' in exports;\n  for (var key in exports) {\n    hasExports = true;\n    if (key === '__esModule') {\n      continue;\n    }\n    var desc = Object.getOwnPropertyDescriptor(exports, key);\n    if (desc && desc.get && !isESM) {\n      // Don't invoke getters for CJS as they may have side effects.\n      return false;\n    }\n    var exportValue = exports[key];\n    if (!Refresh.isLikelyComponentType(exportValue)) {\n      areAllExportsComponents = false;\n    }\n  }\n  return hasExports && areAllExportsComponents;\n}\nfunction shouldInvalidateReactRefreshBoundary(prevExports, nextExports) {\n  var prevSignature = getRefreshBoundarySignature(prevExports);\n  var nextSignature = getRefreshBoundarySignature(nextExports);\n  if (prevSignature.length !== nextSignature.length) {\n    return true;\n  }\n  for (var i = 0; i < nextSignature.length; i++) {\n    if (prevSignature[i] !== nextSignature[i]) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// When this signature changes, it's unsafe to stop at this refresh boundary.\nfunction getRefreshBoundarySignature(exports) {\n  var signature = [];\n  signature.push(Refresh.getFamilyByType(exports));\n  if (exports == null || typeof exports !== 'object') {\n    // Exit if we can't iterate over exports.\n    // (This is important for legacy environments.)\n    return signature;\n  }\n  let isESM = '__esModule' in exports;\n  for (var key in exports) {\n    if (key === '__esModule') {\n      continue;\n    }\n    var desc = Object.getOwnPropertyDescriptor(exports, key);\n    if (desc && desc.get && !isESM) {\n      // Don't invoke getters for CJS as they may have side effects.\n      continue;\n    }\n    var exportValue = exports[key];\n    signature.push(key);\n    signature.push(Refresh.getFamilyByType(exportValue));\n  }\n  return signature;\n}\nfunction registerExportsForReactRefresh(module) {\n  var exports = module.exports,\n    id = module.id;\n  Refresh.register(exports, id + ' %exports%');\n  if (exports == null || typeof exports !== 'object') {\n    // Exit if we can't iterate over exports.\n    // (This is important for legacy environments.)\n    return;\n  }\n  let isESM = '__esModule' in exports;\n  for (var key in exports) {\n    var desc = Object.getOwnPropertyDescriptor(exports, key);\n    if (desc && desc.get && !isESM) {\n      // Don't invoke getters for CJS as they may have side effects.\n      continue;\n    }\n    var exportValue = exports[key];\n    var typeID = id + ' %exports% ' + key;\n    Refresh.register(exportValue, typeID);\n  }\n}","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-refresh-runtime.production.min.js');\n} else {\n  module.exports = require('./cjs/react-refresh-runtime.development.js');\n}\n","/**\n * @license React\n * react-refresh-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\n// ATTENTION\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\n\nvar PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.\n// It's OK to reference families, but use WeakMap/Set for types.\n\nvar allFamiliesByID = new Map();\nvar allFamiliesByType = new PossiblyWeakMap();\nvar allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families\n// that have actually been edited here. This keeps checks fast.\n// $FlowIssue\n\nvar updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.\n// It is an array of [Family, NextType] tuples.\n\nvar pendingUpdates = []; // This is injected by the renderer via DevTools global hook.\n\nvar helpersByRendererID = new Map();\nvar helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.\n\nvar mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.\n\nvar failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.\n// It needs to be weak because we do this even for roots that failed to mount.\n// If there is no WeakMap, we won't attempt to do retrying.\n// $FlowIssue\n\nvar rootElements = // $FlowIssue\ntypeof WeakMap === 'function' ? new WeakMap() : null;\nvar isPerformingRefresh = false;\n\nfunction computeFullKey(signature) {\n  if (signature.fullKey !== null) {\n    return signature.fullKey;\n  }\n\n  var fullKey = signature.ownKey;\n  var hooks;\n\n  try {\n    hooks = signature.getCustomHooks();\n  } catch (err) {\n    // This can happen in an edge case, e.g. if expression like Foo.useSomething\n    // depends on Foo which is lazily initialized during rendering.\n    // In that case just assume we'll have to remount.\n    signature.forceReset = true;\n    signature.fullKey = fullKey;\n    return fullKey;\n  }\n\n  for (var i = 0; i < hooks.length; i++) {\n    var hook = hooks[i];\n\n    if (typeof hook !== 'function') {\n      // Something's wrong. Assume we need to remount.\n      signature.forceReset = true;\n      signature.fullKey = fullKey;\n      return fullKey;\n    }\n\n    var nestedHookSignature = allSignaturesByType.get(hook);\n\n    if (nestedHookSignature === undefined) {\n      // No signature means Hook wasn't in the source code, e.g. in a library.\n      // We'll skip it because we can assume it won't change during this session.\n      continue;\n    }\n\n    var nestedHookKey = computeFullKey(nestedHookSignature);\n\n    if (nestedHookSignature.forceReset) {\n      signature.forceReset = true;\n    }\n\n    fullKey += '\\n---\\n' + nestedHookKey;\n  }\n\n  signature.fullKey = fullKey;\n  return fullKey;\n}\n\nfunction haveEqualSignatures(prevType, nextType) {\n  var prevSignature = allSignaturesByType.get(prevType);\n  var nextSignature = allSignaturesByType.get(nextType);\n\n  if (prevSignature === undefined && nextSignature === undefined) {\n    return true;\n  }\n\n  if (prevSignature === undefined || nextSignature === undefined) {\n    return false;\n  }\n\n  if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n    return false;\n  }\n\n  if (nextSignature.forceReset) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isReactClass(type) {\n  return type.prototype && type.prototype.isReactComponent;\n}\n\nfunction canPreserveStateBetween(prevType, nextType) {\n  if (isReactClass(prevType) || isReactClass(nextType)) {\n    return false;\n  }\n\n  if (haveEqualSignatures(prevType, nextType)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction resolveFamily(type) {\n  // Only check updated types to keep lookups fast.\n  return updatedFamiliesByType.get(type);\n} // If we didn't care about IE11, we could use new Map/Set(iterable).\n\n\nfunction cloneMap(map) {\n  var clone = new Map();\n  map.forEach(function (value, key) {\n    clone.set(key, value);\n  });\n  return clone;\n}\n\nfunction cloneSet(set) {\n  var clone = new Set();\n  set.forEach(function (value) {\n    clone.add(value);\n  });\n  return clone;\n} // This is a safety mechanism to protect against rogue getters and Proxies.\n\n\nfunction getProperty(object, property) {\n  try {\n    return object[property];\n  } catch (err) {\n    // Intentionally ignore.\n    return undefined;\n  }\n}\n\nfunction performReactRefresh() {\n\n  if (pendingUpdates.length === 0) {\n    return null;\n  }\n\n  if (isPerformingRefresh) {\n    return null;\n  }\n\n  isPerformingRefresh = true;\n\n  try {\n    var staleFamilies = new Set();\n    var updatedFamilies = new Set();\n    var updates = pendingUpdates;\n    pendingUpdates = [];\n    updates.forEach(function (_ref) {\n      var family = _ref[0],\n          nextType = _ref[1];\n      // Now that we got a real edit, we can create associations\n      // that will be read by the React reconciler.\n      var prevType = family.current;\n      updatedFamiliesByType.set(prevType, family);\n      updatedFamiliesByType.set(nextType, family);\n      family.current = nextType; // Determine whether this should be a re-render or a re-mount.\n\n      if (canPreserveStateBetween(prevType, nextType)) {\n        updatedFamilies.add(family);\n      } else {\n        staleFamilies.add(family);\n      }\n    }); // TODO: rename these fields to something more meaningful.\n\n    var update = {\n      updatedFamilies: updatedFamilies,\n      // Families that will re-render preserving state\n      staleFamilies: staleFamilies // Families that will be remounted\n\n    };\n    helpersByRendererID.forEach(function (helpers) {\n      // Even if there are no roots, set the handler on first update.\n      // This ensures that if *new* roots are mounted, they'll use the resolve handler.\n      helpers.setRefreshHandler(resolveFamily);\n    });\n    var didError = false;\n    var firstError = null; // We snapshot maps and sets that are mutated during commits.\n    // If we don't do this, there is a risk they will be mutated while\n    // we iterate over them. For example, trying to recover a failed root\n    // may cause another root to be added to the failed list -- an infinite loop.\n\n    var failedRootsSnapshot = cloneSet(failedRoots);\n    var mountedRootsSnapshot = cloneSet(mountedRoots);\n    var helpersByRootSnapshot = cloneMap(helpersByRoot);\n    failedRootsSnapshot.forEach(function (root) {\n      var helpers = helpersByRootSnapshot.get(root);\n\n      if (helpers === undefined) {\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n      }\n\n      if (!failedRoots.has(root)) {// No longer failed.\n      }\n\n      if (rootElements === null) {\n        return;\n      }\n\n      if (!rootElements.has(root)) {\n        return;\n      }\n\n      var element = rootElements.get(root);\n\n      try {\n        helpers.scheduleRoot(root, element);\n      } catch (err) {\n        if (!didError) {\n          didError = true;\n          firstError = err;\n        } // Keep trying other roots.\n\n      }\n    });\n    mountedRootsSnapshot.forEach(function (root) {\n      var helpers = helpersByRootSnapshot.get(root);\n\n      if (helpers === undefined) {\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n      }\n\n      if (!mountedRoots.has(root)) {// No longer mounted.\n      }\n\n      try {\n        helpers.scheduleRefresh(root, update);\n      } catch (err) {\n        if (!didError) {\n          didError = true;\n          firstError = err;\n        } // Keep trying other roots.\n\n      }\n    });\n\n    if (didError) {\n      throw firstError;\n    }\n\n    return update;\n  } finally {\n    isPerformingRefresh = false;\n  }\n}\nfunction register(type, id) {\n  {\n    if (type === null) {\n      return;\n    }\n\n    if (typeof type !== 'function' && typeof type !== 'object') {\n      return;\n    } // This can happen in an edge case, e.g. if we register\n    // return value of a HOC but it returns a cached component.\n    // Ignore anything but the first registration for each type.\n\n\n    if (allFamiliesByType.has(type)) {\n      return;\n    } // Create family or remember to update it.\n    // None of this bookkeeping affects reconciliation\n    // until the first performReactRefresh() call above.\n\n\n    var family = allFamiliesByID.get(id);\n\n    if (family === undefined) {\n      family = {\n        current: type\n      };\n      allFamiliesByID.set(id, family);\n    } else {\n      pendingUpdates.push([family, type]);\n    }\n\n    allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.\n\n    if (typeof type === 'object' && type !== null) {\n      switch (getProperty(type, '$$typeof')) {\n        case REACT_FORWARD_REF_TYPE:\n          register(type.render, id + '$render');\n          break;\n\n        case REACT_MEMO_TYPE:\n          register(type.type, id + '$type');\n          break;\n      }\n    }\n  }\n}\nfunction setSignature(type, key) {\n  var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;\n\n  {\n    if (!allSignaturesByType.has(type)) {\n      allSignaturesByType.set(type, {\n        forceReset: forceReset,\n        ownKey: key,\n        fullKey: null,\n        getCustomHooks: getCustomHooks || function () {\n          return [];\n        }\n      });\n    } // Visit inner types because we might not have signed them.\n\n\n    if (typeof type === 'object' && type !== null) {\n      switch (getProperty(type, '$$typeof')) {\n        case REACT_FORWARD_REF_TYPE:\n          setSignature(type.render, key, forceReset, getCustomHooks);\n          break;\n\n        case REACT_MEMO_TYPE:\n          setSignature(type.type, key, forceReset, getCustomHooks);\n          break;\n      }\n    }\n  }\n} // This is lazily called during first render for a type.\n// It captures Hook list at that time so inline requires don't break comparisons.\n\nfunction collectCustomHooksForSignature(type) {\n  {\n    var signature = allSignaturesByType.get(type);\n\n    if (signature !== undefined) {\n      computeFullKey(signature);\n    }\n  }\n}\nfunction getFamilyByID(id) {\n  {\n    return allFamiliesByID.get(id);\n  }\n}\nfunction getFamilyByType(type) {\n  {\n    return allFamiliesByType.get(type);\n  }\n}\nfunction findAffectedHostInstances(families) {\n  {\n    var affectedInstances = new Set();\n    mountedRoots.forEach(function (root) {\n      var helpers = helpersByRoot.get(root);\n\n      if (helpers === undefined) {\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n      }\n\n      var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\n      instancesForRoot.forEach(function (inst) {\n        affectedInstances.add(inst);\n      });\n    });\n    return affectedInstances;\n  }\n}\nfunction injectIntoGlobalHook(globalObject) {\n  {\n    // For React Native, the global hook will be set up by require('react-devtools-core').\n    // That code will run before us. So we need to monkeypatch functions on existing hook.\n    // For React Web, the global hook will be set up by the extension.\n    // This will also run before us.\n    var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n    if (hook === undefined) {\n      // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.\n      // Note that in this case it's important that renderer code runs *after* this method call.\n      // Otherwise, the renderer will think that there is no global hook, and won't do the injection.\n      var nextID = 0;\n      globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n        renderers: new Map(),\n        supportsFiber: true,\n        inject: function (injected) {\n          return nextID++;\n        },\n        onScheduleFiberRoot: function (id, root, children) {},\n        onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},\n        onCommitFiberUnmount: function () {}\n      };\n    }\n\n    if (hook.isDisabled) {\n      // This isn't a real property on the hook, but it can be set to opt out\n      // of DevTools integration and associated warnings and logs.\n      // Using console['warn'] to evade Babel and ESLint\n      console['warn']('Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' + 'Fast Refresh is not compatible with this shim and will be disabled.');\n      return;\n    } // Here, we just want to get a reference to scheduleRefresh.\n\n\n    var oldInject = hook.inject;\n\n    hook.inject = function (injected) {\n      var id = oldInject.apply(this, arguments);\n\n      if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n        // This version supports React Refresh.\n        helpersByRendererID.set(id, injected);\n      }\n\n      return id;\n    }; // Do the same for any already injected roots.\n    // This is useful if ReactDOM has already been initialized.\n    // https://github.com/facebook/react/issues/17626\n\n\n    hook.renderers.forEach(function (injected, id) {\n      if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n        // This version supports React Refresh.\n        helpersByRendererID.set(id, injected);\n      }\n    }); // We also want to track currently mounted roots.\n\n    var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n\n    var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function () {};\n\n    hook.onScheduleFiberRoot = function (id, root, children) {\n      if (!isPerformingRefresh) {\n        // If it was intentionally scheduled, don't attempt to restore.\n        // This includes intentionally scheduled unmounts.\n        failedRoots.delete(root);\n\n        if (rootElements !== null) {\n          rootElements.set(root, children);\n        }\n      }\n\n      return oldOnScheduleFiberRoot.apply(this, arguments);\n    };\n\n    hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {\n      var helpers = helpersByRendererID.get(id);\n\n      if (helpers !== undefined) {\n        helpersByRoot.set(root, helpers);\n        var current = root.current;\n        var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.\n        // This logic is copy-pasted from similar logic in the DevTools backend.\n        // If this breaks with some refactoring, you'll want to update DevTools too.\n\n        if (alternate !== null) {\n          var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);\n          var isMounted = current.memoizedState != null && current.memoizedState.element != null;\n\n          if (!wasMounted && isMounted) {\n            // Mount a new root.\n            mountedRoots.add(root);\n            failedRoots.delete(root);\n          } else if (wasMounted && isMounted) ; else if (wasMounted && !isMounted) {\n            // Unmount an existing root.\n            mountedRoots.delete(root);\n\n            if (didError) {\n              // We'll remount it on future edits.\n              failedRoots.add(root);\n            } else {\n              helpersByRoot.delete(root);\n            }\n          } else if (!wasMounted && !isMounted) {\n            if (didError) {\n              // We'll remount it on future edits.\n              failedRoots.add(root);\n            }\n          }\n        } else {\n          // Mount a new root.\n          mountedRoots.add(root);\n        }\n      } // Always call the decorated DevTools hook.\n\n\n      return oldOnCommitFiberRoot.apply(this, arguments);\n    };\n  }\n}\nfunction hasUnrecoverableErrors() {\n  // TODO: delete this after removing dependency in RN.\n  return false;\n} // Exposed for testing.\n\nfunction _getMountedRootCount() {\n  {\n    return mountedRoots.size;\n  }\n} // This is a wrapper over more primitive functions for setting signature.\n// Signatures let us decide whether the Hook order has changed on refresh.\n//\n// This function is intended to be used as a transform target, e.g.:\n// var _s = createSignatureFunctionForTransform()\n//\n// function Hello() {\n//   const [foo, setFoo] = useState(0);\n//   const value = useCustomHook();\n//   _s(); /* Call without arguments triggers collecting the custom Hook list.\n//          * This doesn't happen during the module evaluation because we\n//          * don't want to change the module order with inline requires.\n//          * Next calls are noops. */\n//   return <h1>Hi</h1>;\n// }\n//\n// /* Call with arguments attaches the signature to the type: */\n// _s(\n//   Hello,\n//   'useState{[foo, setFoo]}(0)',\n//   () => [useCustomHook], /* Lazy to avoid triggering inline requires */\n// );\n\nfunction createSignatureFunctionForTransform() {\n  {\n    var savedType;\n    var hasCustomHooks;\n    var didCollectHooks = false;\n    return function (type, key, forceReset, getCustomHooks) {\n      if (typeof key === 'string') {\n        // We're in the initial phase that associates signatures\n        // with the functions. Note this may be called multiple times\n        // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).\n        if (!savedType) {\n          // We're in the innermost call, so this is the actual type.\n          savedType = type;\n          hasCustomHooks = typeof getCustomHooks === 'function';\n        } // Set the signature for all types (even wrappers!) in case\n        // they have no signatures of their own. This is to prevent\n        // problems like https://github.com/facebook/react/issues/20417.\n\n\n        if (type != null && (typeof type === 'function' || typeof type === 'object')) {\n          setSignature(type, key, forceReset, getCustomHooks);\n        }\n\n        return type;\n      } else {\n        // We're in the _s() call without arguments, which means\n        // this is the time to collect custom Hook signatures.\n        // Only do this once. This path is hot and runs *inside* every render!\n        if (!didCollectHooks && hasCustomHooks) {\n          didCollectHooks = true;\n          collectCustomHooksForSignature(savedType);\n        }\n      }\n    };\n  }\n}\nfunction isLikelyComponentType(type) {\n  {\n    switch (typeof type) {\n      case 'function':\n        {\n          // First, deal with classes.\n          if (type.prototype != null) {\n            if (type.prototype.isReactComponent) {\n              // React class.\n              return true;\n            }\n\n            var ownNames = Object.getOwnPropertyNames(type.prototype);\n\n            if (ownNames.length > 1 || ownNames[0] !== 'constructor') {\n              // This looks like a class.\n              return false;\n            } // eslint-disable-next-line no-proto\n\n\n            if (type.prototype.__proto__ !== Object.prototype) {\n              // It has a superclass.\n              return false;\n            } // Pass through.\n            // This looks like a regular function with empty prototype.\n\n          } // For plain functions and arrows, use name as a heuristic.\n\n\n          var name = type.name || type.displayName;\n          return typeof name === 'string' && /^[A-Z]/.test(name);\n        }\n\n      case 'object':\n        {\n          if (type != null) {\n            switch (getProperty(type, '$$typeof')) {\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_MEMO_TYPE:\n                // Definitely React components.\n                return true;\n\n              default:\n                return false;\n            }\n          }\n\n          return false;\n        }\n\n      default:\n        {\n          return false;\n        }\n    }\n  }\n}\n\nexports._getMountedRootCount = _getMountedRootCount;\nexports.collectCustomHooksForSignature = collectCustomHooksForSignature;\nexports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;\nexports.findAffectedHostInstances = findAffectedHostInstances;\nexports.getFamilyByID = getFamilyByID;\nexports.getFamilyByType = getFamilyByType;\nexports.hasUnrecoverableErrors = hasUnrecoverableErrors;\nexports.injectIntoGlobalHook = injectIntoGlobalHook;\nexports.isLikelyComponentType = isLikelyComponentType;\nexports.performReactRefresh = performReactRefresh;\nexports.register = register;\nexports.setSignature = setSignature;\n  })();\n}\n","{\n  \"name\": \"react-refresh\",\n  \"description\": \"React is a JavaScript library for building user interfaces.\",\n  \"keywords\": [\n    \"react\"\n  ],\n  \"version\": \"0.14.2\",\n  \"homepage\": \"https://reactjs.org/\",\n  \"bugs\": \"https://github.com/facebook/react/issues\",\n  \"license\": \"MIT\",\n  \"files\": [\n    \"LICENSE\",\n    \"README.md\",\n    \"babel.js\",\n    \"runtime.js\",\n    \"cjs/\",\n    \"umd/\"\n  ],\n  \"main\": \"runtime.js\",\n  \"exports\": {\n    \".\": \"./runtime.js\",\n    \"./runtime\": \"./runtime.js\",\n    \"./babel\": \"./babel.js\",\n    \"./package.json\": \"./package.json\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/facebook/react.git\",\n    \"directory\": \"packages/react\"\n  },\n  \"engines\": {\n    \"node\": \">=0.10.0\"\n  },\n  \"devDependencies\": {\n    \"react-16-8\": \"npm:react@16.8.0\",\n    \"react-dom-16-8\": \"npm:react-dom@16.8.0\",\n    \"scheduler-0-13\": \"npm:scheduler@0.13.0\"\n  }\n}"],"names":["assign","obj","props","i","shallowDiffers","a","b","useSyncExternalStore","subscribe","getSnapshot","value","_useState","useState","_instance","__","_getSnapshot","forceUpdate","useLayoutEffect","didSnapshotChange","useEffect","inst","x","y","latestGetSnapshot","prevValue","nextValue","error","startTransition","cb","useDeferredValue","val","useTransition","useInsertionEffect","PureComponent","p","c","this","context","memo","comparer","shouldUpdate","nextProps","ref","updateRef","call","current","Memoed","shouldComponentUpdate","createElement","displayName","name","prototype","isReactComponent","__f","Component","isPureReactComponent","state","oldDiffHook","options","__b","vnode","type","REACT_FORWARD_SYMBOL","Symbol","for","forwardRef","fn","Forwarded","clone","$$typeof","render","mapFn","children","toChildArray","map","Children","forEach","count","length","only","normalized","toArray","oldCatchError","__e","newVNode","oldVNode","errorInfo","then","component","__c","__k","oldUnmount","unmount","detachedClone","detachedParent","parentDom","__H","effect","__P","child","removeOriginal","originalParent","__v","appendChild","Suspense","__u","_suspenders","suspended","__a","lazy","loader","prom","Lazy","exports","default","e","SuspenseList","_next","_map","__R","promise","suspendingVNode","suspendingComponent","push","resolve","resolved","onResolved","onSuspensionComplete","suspendedVNode","__O","setState","pop","componentWillUnmount","document","detachedComponent","fallback","Fragment","list","node","delete","revealOrder","size","ContextProvider","getChildContext","Portal","_this","container","_container","_temp","nodeType","parentNode","childNodes","contains","insertBefore","before","removeChild","splice","indexOf","createPortal","el","containerInfo","delegated","get","unsuspend","wrappedUnsuspend","Map","reverse","set","componentDidUpdate","componentDidMount","REACT_ELEMENT_TYPE","CAMEL_PROPS","ON_ANI","CAMEL_REPLACE","IS_DOM","onChangeInputType","test","parent","callback","textContent","preactRender","hydrate","preactHydrate","key","Object","defineProperty","configurable","v","writable","oldEventHook","event","empty","isPropagationStopped","cancelBubble","isDefaultPrevented","defaultPrevented","persist","nativeEvent","currentComponent","classNameDescriptorNonEnumberable","enumerable","class","oldVNodeHook","normalizedProps","isNonDashedType","lowerCased","toLowerCase","replace","undefined","multiple","Array","isArray","selected","defaultValue","className","handleDomVNode","oldBeforeRender","__r","oldDiffed","diffed","dom","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","readContext","__n","useCallback","useContext","useDebugValue","useId","useImperativeHandle","useMemo","useReducer","useRef","version","createFactory","bind","isValidElement","element","isFragment","isMemo","String","startsWith","cloneElement","preactCloneElement","apply","arguments","unmountComponentAtNode","findDOMNode","base","unstable_batchedUpdates","arg","flushSync","StrictMode","isElement","index","createContext","createRef","slice","vnodeId","rerenderQueue","prevDebounce","defer","depthSort","CAPTURE_REGEX","eventClock","eventProxy","eventProxyCapture","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","removeNode","defaultProps","createVNode","original","constructor","__i","BaseComponent","getDomSibling","childIndex","sibling","updateParentDomPointers","enqueueRender","__d","process","debounceRendering","oldDom","commitQueue","refQueue","l","sort","shift","diff","namespaceURI","commitRoot","diffChildren","renderResult","newParentVNode","oldParentVNode","globalContext","namespace","excessDomChildren","isHydrating","childVNode","newDom","firstChildDom","result","oldChildren","newChildrenLength","constructNewChildrenArray","applyRef","insert","nextSibling","skewedIndex","matchingIndex","oldChildrenLength","remainingOldChildren","skew","findMatchingIndex","parentVNode","out","some","setStyle","style","setProperty","oldValue","useCapture","o","cssText","_attached","addEventListener","removeEventListener","removeAttribute","setAttribute","createEventProxy","eventHandler","_dispatched","tmp","isNew","oldProps","oldState","snapshot","clearProcessingException","newProps","isClassComponent","provider","componentContext","renderHook","newType","outer","contextType","__E","doRender","sub","__h","_sb","__s","getDerivedStateFromProps","componentWillMount","componentWillReceiveProps","componentWillUpdate","getSnapshotBeforeUpdate","cloneNode","MODE_HYDRATE","diffElementNodes","root","newHtml","oldHtml","newChildren","inputValue","checked","localName","createTextNode","createElementNS","is","__m","data","attributes","__html","innerHTML","content","hasRefUnmount","skipRemove","r","replaceNode","documentElement","firstChild","Context","subs","ctx","Set","_props","add","old","Provider","__l","Consumer","contextValue","ctor","handled","getDerivedStateFromError","componentDidCatch","update","s","Promise","setTimeout","currentIndex","previousComponent","prevRaf","currentHook","afterPaintEffects","_options","oldBeforeDiff","oldAfterDiff","oldCommit","oldBeforeUnmount","oldRoot","getHookState","hooks","initialState","invokeOrReturn","reducer","init","hookState","_reducer","action","currentValue","__N","updateHookState","stateHooks","filter","every","prevScu","hookItem","prevCWU","args","argsChanged","_pendingArgs","initialValue","createHandle","concat","factory","formatter","useErrorBoundary","errState","err","mask","flushAfterPaintEffects","invokeCleanup","invokeEffect","requestAnimationFrame","afterNextFrame","hasErrored","HAS_RAF","raf","done","clearTimeout","timeout","cancelAnimationFrame","hook","comp","cleanup","oldArgs","newArgs","f","ENCODED_ENTITIES","encodeEntities","str","last","ch","charCodeAt","isStaticChildren","__source","__self","jsxTemplate","templates","tpl","exprs","JS_TO_CSS","CSS_REGEX","jsxAttr","attr","prop","suffix","jsxEscape"],"version":3,"file":"index.cbef2d5a.js.map","sourceRoot":"/__parcel_source_root/"}